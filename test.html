<!DOCTYPE html>
<html>
<head>
  <title>WebRTC Test Call</title>
  <style>
    body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
    #users { margin: 10px; }
    video { width: 300px; height: 200px; background: #000; margin: 10px; }
    #incomingCallPopup {
      display: none;
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 20px;
      background: white;
      border: 1px solid #ccc;
      z-index: 100;
    }
  </style>
</head>
<body>
  <h1>Test Call</h1>
  <div id="users"></div>
  <video id="localVideo" autoplay muted playsinline></video>
  <video id="remoteVideo" autoplay playsinline></video>

  <div id="incomingCallPopup">
    <p id="callerInfo">Incoming call...</p>
    <button onclick="acceptCall()">Accept</button>
    <button onclick="rejectCall()">Reject</button>
    <button onclick="cancelPopup()">Cancel</button>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDhBr_m8D2A5xQqCctYwhuAZlmnC4BldUw",
      authDomain: "locater-42fb4.firebaseapp.com",
      databaseURL: "https://locater-42fb4-default-rtdb.firebaseio.com",
      projectId: "locater-42fb4",
      storageBucket: "locater-42fb4.appspot.com",
      messagingSenderId: "19144314605",
      appId: "1:19144314605:web:bf92bbfdac2626d77b6028"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let currentUser = prompt("Enter your username:");
    let pc = null;
    let localStream = null;
    let remoteStream = null;
    let pendingCandidates = [];

    const usersDiv = document.getElementById("users");
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const popup = document.getElementById("incomingCallPopup");
    const callerInfo = document.getElementById("callerInfo");

    const callRef = db.ref("calls");

    db.ref("users").once("value", snap => {
      const users = snap.val();
      for (const user in users) {
        if (user === currentUser) continue;
        const btn = document.createElement("button");
        btn.innerText = "Call " + user;
        btn.onclick = () => startCall(user);
        usersDiv.appendChild(btn);
      }
    });

    function showPopup(caller) {
      callerInfo.innerText = `Call from ${caller}`;
      popup.style.display = "block";
    }

    function cancelPopup() {
      popup.style.display = "none";
    }

    function rejectCall() {
      if (incomingCallFrom) {
        db.ref(`calls/${incomingCallFrom}/status`).set("rejected");
      }
      cancelPopup();
    }

    function acceptCall() {
      popup.style.display = "none";
      setupConnection(incomingCallFrom, false); // isCaller = false
    }

    function createPeerConnection(remoteUser, isCaller) {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      pc.ontrack = e => {
        e.streams[0].getTracks().forEach(track => remoteStream.addTrack(track));
      };

      pc.onicecandidate = e => {
        if (e.candidate) {
          db.ref(`calls/${remoteUser}/ice`).push(JSON.stringify(e.candidate));
        }
      };
    }

    async function setupConnection(remoteUser, isCaller) {
      createPeerConnection(remoteUser, isCaller);
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localVideo.srcObject = localStream;
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      if (isCaller) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await db.ref(`calls/${remoteUser}`).set({ from: currentUser, offer: JSON.stringify(offer), status: "ringing" });
      } else {
        db.ref(`calls/${currentUser}/offer`).once("value", async snap => {
          const offer = JSON.parse(snap.val());
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          await db.ref(`calls/${currentUser}/answer`).set(JSON.stringify(answer));

          for (const c of pendingCandidates) {
            await pc.addIceCandidate(new RTCIceCandidate(c));
          }
          pendingCandidates = [];
        });
      }

      // Listen for remote ICE
      db.ref(`calls/${currentUser}/ice`).on("child_added", async snap => {
        const ice = JSON.parse(snap.val());
        if (pc.remoteDescription) {
          try {
            await pc.addIceCandidate(new RTCIceCandidate(ice));
          } catch (err) {
            console.error("ICE add error", err);
          }
        } else {
          pendingCandidates.push(ice);
        }
      });

      // If receiver, listen for answer
      if (isCaller) {
        db.ref(`calls/${remoteUser}/answer`).on("value", async snap => {
          if (snap.exists()) {
            const answer = JSON.parse(snap.val());
            await pc.setRemoteDescription(new RTCSessionDescription(answer));
          }
        });

        // End call after 1 minute if no answer
        setTimeout(() => {
          db.ref(`calls/${remoteUser}/status`).once("value", snap => {
            if (snap.val() !== "answered") {
              endCall(remoteUser);
            }
          });
        }, 60000);
      }
    }

    async function startCall(targetUser) {
      await setupConnection(targetUser, true);
    }

    function endCall(remoteUser) {
      if (pc) pc.close();
      pc = null;
      db.ref(`calls/${remoteUser}`).remove();
    }

    let incomingCallFrom = null;

    // Listen for incoming calls
    db.ref(`calls/${currentUser}`).on("value", snap => {
      const data = snap.val();
      if (data && data.status === "ringing") {
        incomingCallFrom = data.from;
        showPopup(incomingCallFrom);
      }
    });
  </script>
</body>
</html>
