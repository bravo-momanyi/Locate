<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bravo Chat & Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
 <style>  
  /* General */  
  body, html {  
    margin: 0;  
    padding: 0;  
    height: 100%;  
    font-family: Arial, sans-serif;  
    background: #fff;  
    overflow: hidden;  
  }  

  /* Header */
  header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #075E54;
    color: white;
    padding: 10px;
    font-size: 16px;
  }

  /* Tabs */
  .tabs {
    display: flex;
    background: #128C7E;
  }

  .tabs button {
    flex: 1;
    padding: 12px;
    border: none;
    background: #128C7E;
    color: white;
    cursor: pointer;
    font-size: 15px;
  }

  .tabs button.active {
    background: #25D366;
    font-weight: bold;
  }

  /* Content Areas */
  .content {
    display: none;
    height: calc(100% - 92px);
    overflow: hidden;
  }

  .content.active {
    display: flex;
  }

  #mapContent {
    position: relative;
  }

  #map {
    width: 100%;
    height: 100%;
  }

  /* Chat Layout */
  #chatContent {
    display: flex;
    width: 100%;
  }

  /* User List */
  #userList {
    width: 30%;
    border-right: 1px solid #ddd;
    overflow-y: auto;
    padding: 10px;
    box-sizing: border-box;
    background: #fafafa;
  }

  #userList input,
  #userList button {
    width: 100%;
    margin-bottom: 5px;
    padding: 8px;
    border: none;
    border-radius: 4px;
    box-sizing: border-box;
  }

  #userList input {
    border: 1px solid #ccc;
  }

  #userList button {
    background: #f1f1f1;
    cursor: pointer;
  }

  #userList button.group {
    background: #e1f5fe;
    font-weight: bold;
  }

  /* Chat Window */
  #chatWindow {
    flex: 1;
    display: none;
    flex-direction: column;
    position: relative;
    background: white;
    height: 100%;
  }

  /* Chat Header */
  #chatHeader {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px;
  background: #128C7E;
  color: white;
  font-size: 16px;
}

#chatWith {
  font-weight: bold;
  text-align: center;
  text-decoration: underline;
  cursor: pointer;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  white-space: nowrap;
}

#backBtn {
  position: absolute;
  left: 10px;
  background: white;
  color: #128C7E;
  border: none;
  padding: 5px 10px;
  border-radius: 5px;
  font-size: 14px;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
  z-index: 2;
}

.callGroup {
  position: absolute;
  right: 10px;
  display: flex;
  gap: 5px;
  z-index: 2;
}

  .callGroup button {
    padding: 6px 10px;
    border: none;
    border-radius: 5px;
    color: white;
    font-size: 14px;
    cursor: pointer;
  }

  .callGroup .voice {
    background: #075E54;
  }

  .callGroup .video {
    background: #128C7E;
  }

  /* Messages Area */
  #messages {
    flex: 1;
    padding: 10px;
    overflow-y: auto;
    background: #e5ddd5;
    display: flex;
    flex-direction: column;
  }

  /* Individual Message */
  .msg {
    padding: 8px;
    margin: 5px;
    border-radius: 7px;
    max-width: 70%;
    word-wrap: break-word;
  }

  .you {
    background: #dcf8c6;
    align-self: flex-end;
  }

  .them {
    background: white;
    align-self: flex-start;
  }

  /* Send Bar */
  #sendBar {
    display: flex;
    padding: 10px;
    border-top: 1px solid #ccc;
    background: #fff;
  }

  #sendBar input {
    flex: 1;
    padding: 8px;
    border-radius: 20px;
    border: 1px solid #ccc;
    font-size: 14px;
  }

  #sendBar button {
    padding: 8px 12px;
    background: #25D366;
    border: none;
    color: white;
    margin-left: 5px;
    border-radius: 20px;
    font-size: 14px;
    cursor: pointer;
  }

  /* Mobile Responsive */
  @media (max-width: 600px) {
    #userList {
      width: 100%;
    }

    #chatWindow {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      background: white;
      z-index: 100;
    }

    #chatHeader {
      display: none;
    }

    #backBtn {
      display: inline-block;
    }
  }
  </style>
</head>
<body>
  <header>
    <div id="currentUser"></div>
    <button onclick="logout()">Logout</button>
  </header>

  <div class="tabs">
    <button class="active" onclick="openTab('mapContent')">Map</button>
    <button onclick="openTab('chatContent')">Chats</button>
  </div>

  <div id="mapContent" class="content active">
    <div id="map"></div>
  </div>

  <div id="chatContent" class="content">
    <div id="userList">
      <input id="searchBox" placeholder="Search users/groups..." />
      <button onclick="createGroup()">Create Group</button>
      <div id="users"></div>
    </div>
    <div id="chatWindow">
      <div id="chatHeader">
        <button id="backBtn" onclick="closeChat()">â¬…</button>
        <div class="chatTitleWrapper">
          <span id="chatWith" onclick="openChatOptions()">---</span>
        </div>
        <div class="callGroup">
          <button class="voice" onclick="startCall('voice')">ðŸ“ž</button>
          <button class="video" onclick="startCall('video')">ðŸŽ¥</button>
        </div>
      </div>

    

      <div id="messages"></div>

      <div id="sendBar">
        <input id="msgInput" placeholder="Type message..." oninput="notifyTyping()" />
        <button onclick="sendMsg()">Send</button>
      </div>
    </div>
  </div>

  <!-- CALL MODAL -->
  <div id="callModal" style="
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000c;
      z-index: 9999;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    ">
    <video id="remoteVideo" autoplay playsinline style="width:90%; max-width:500px; background:black;"></video>
    <video id="localVideo" muted autoplay playsinline style="
        position: absolute;
        bottom: 20px;
        right: 20px;
        width: 100px;
        border: 2px solid white;
        border-radius: 10px;
      "></video>
    <button onclick="endCall()" style="
        margin-top: 20px;
        padding: 10px 20px;
        background: red;
        color: white;
        border: none;
        border-radius: 5px;
      ">End Call</button>
  </div>
  <div id="callModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#000; z-index:9999; flex-direction:column; align-items:center; justify-content:center;">
  <video id="remoteVideo" autoplay playsinline style="width:100%; max-height:70%;"></video>
  <video id="localVideo" muted autoplay playsinline style="width:30%; position:absolute; bottom:80px; right:20px; border:2px solid #fff;"></video>
  <button onclick="endCall()" style="margin-top:20px; background:red; color:#fff; padding:10px 20px;">End Call</button>
  </div>
</body>
</html>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
<script>
  const config = {
    apiKey: "AIzaSyBfkUJS81minjxj0DFz4pzNnGzCtb5ZJss",
    authDomain: "locater-42fb4.firebaseapp.com",
    databaseURL: "https://locater-42fb4-default-rtdb.firebaseio.com",
    projectId: "locater-42fb4",
    storageBucket: "locater-42fb4.appspot.com",
    messagingSenderId: "250348367998",
    appId: "1:250348367998:web:d734b2b4c735b5684ae82f"
  };
  firebase.initializeApp(config);
  const db = firebase.database();

  const user = localStorage.getItem('username') || prompt('Enter username');
  localStorage.setItem('username', user);
  document.getElementById('currentUser').textContent = user;
  db.ref('users/' + user).set(true);

  // Map setup
  const map = L.map('map').setView([1.29, 36.82], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
  const markers = {};

  setInterval(() => {
    navigator.geolocation.getCurrentPosition(pos => {
      db.ref('locations/' + user).set({ lat: pos.coords.latitude, lng: pos.coords.longitude });
    });
  }, 5000);

  db.ref('locations').on('value', snap => {
    const locs = snap.val() || {};
    for (const [u, loc] of Object.entries(locs)) {
      if (markers[u]) markers[u].setLatLng([loc.lat, loc.lng]);
      else markers[u] = L.marker([loc.lat, loc.lng]).addTo(map).bindPopup(u);
    }
  });

  // Chat system
  const userList = document.getElementById('users');
  const searchBox = document.getElementById('searchBox');
  let allUsers = {}, allGroups = {}, currentChat = '', convoRef = null;

  db.ref('users').on('value', snap => {
    allUsers = snap.val() || {};
    refreshUserList();
  });

  db.ref('groups').on('value', snap => {
    allGroups = snap.val() || {};
    refreshUserList();
  });

  searchBox.addEventListener('input', refreshUserList);
  function refreshUserList() {
  const searchTerm = searchBox.value.trim().toLowerCase();
  let html = `<h3 style="margin:10px 0 5px;">Users</h3>`;

  // Filter and display users
  Object.keys(allUsers).forEach(u => {
    if (u !== user && u.toLowerCase().includes(searchTerm)) {
      html += `<button onclick="openChat('${u}')">${u}</button>`;
    }
  });

  html += `<h3 style="margin:15px 0 5px;">Groups</h3>`;

  // Filter and display groups
  Object.entries(allGroups).forEach(([id, data]) => {
    if (!data || typeof data.name !== 'string') return;

    const groupName = data.name.trim().toLowerCase();
    
    if (groupName.includes(searchTerm)) {
      const label = data.public ? `# ${data.name}` : `ðŸ”’ ${data.name}`;
      html += `<button class="group" onclick="attemptJoinGroup('${id}', '${data.name}')">${label}</button>`;
    }
  });

  userList.innerHTML = html;
  }
  function createGroup() {
    let name = prompt("Enter group name (no special characters):");
    if (!name) return;
    name = name.trim().replace(/[^a-zA-Z0-9 _-]/g, '').replace(/\s+/g, '_');

    let type = prompt("Group Type: Type 'public' or 'private'").toLowerCase();
    if (type !== 'public' && type !== 'private') {
      alert("Invalid group type. Please type 'public' or 'private'.");
      return;
    }

    const isPublic = type === 'public';
    let password = null;

    if (!isPublic) {
      password = prompt("Enter a password for this private group:");
      if (!password) return alert("Private group must have a password.");
    }

    const groupData = {
      name,
      admin: user,
      public: isPublic,
      password: isPublic ? null : password,
      members: { [user]: true }
    };

    const newRef = db.ref('groups').push();
    newRef.set(groupData, err => {
      if (!err) {
        db.ref('groupChats/' + newRef.key).push({
          from: 'System',
          text: `${user} created this ${type} group.`,
          ts: Date.now()
        });
        alert(`${type.charAt(0).toUpperCase() + type.slice(1)} group created!`);
      }
    });
  }

  function attemptJoinGroup(groupId, groupName) {
    db.ref('groups/' + groupId).once('value').then(snap => {
      const group = snap.val();
      if (!group) return;

      if (group.members && group.members[user]) {
        openGroup(groupId, groupName);
      } else if (!group.public) {
        const pwd = prompt("This is a private group. Enter password:");
        if (pwd === group.password) {
          const confirmJoin = confirm("Correct password. Do you want to join this group?");
          if (confirmJoin) {
            db.ref('groups/' + groupId + '/members/' + user).set(true);
            openGroup(groupId, groupName);
          }
        } else {
          alert("Wrong password.");
        }
      } else {
        const confirmJoin = confirm("Do you want to join this public group?");
        if (confirmJoin) {
          db.ref('groups/' + groupId + '/members/' + user).set(true);
          openGroup(groupId, groupName);
        }
      }
    });
  }
</script>
<script>
function openChat(other) {
  currentChat = other;
  document.getElementById('chatWith').innerHTML = `<span onclick="openChatOptions()" style="cursor:pointer; text-decoration:underline;">${other}</span>`;
  document.getElementById('chatWindow').style.display = 'flex';
document.getElementById('chatHeader').style.display = window.innerWidth <= 600 ? 'flex' : 'flex';
document.getElementById('backBtn').style.display = window.innerWidth <= 600 ? 'inline-block' : 'none';
  document.getElementById('messages').innerHTML = '';

  if (convoRef) convoRef.off();
  const convo = [user, other].sort().join('_');
  convoRef = db.ref('privateChats/' + convo);

  convoRef.on('child_added', snap => {
    renderMessage(snap.key, snap.val());
  });

  convoRef.on('child_changed', snap => {
    updateMessage(snap.key, snap.val());
  });
}
  function openGroup(groupId, displayName) {
  currentChat = 'group__' + groupId;
  document.getElementById('chatWith').innerHTML = `<span onclick="openChatOptions()" style="cursor:pointer; text-decoration:underline;">#${displayName}</span>`;
  document.getElementById('chatWindow').style.display = 'flex';
document.getElementById('chatHeader').style.display = window.innerWidth <= 600 ? 'flex' : 'flex';
document.getElementById('backBtn').style.display = window.innerWidth <= 600 ? 'inline-block' : 'none';
  document.getElementById('messages').innerHTML = '';
    if (window.innerWidth <= 600) {
    document.getElementById('backBtn').style.display = 'inline-block';
    }
  if (convoRef) convoRef.off();
  convoRef = db.ref('groupChats/' + groupId);

  convoRef.on('child_added', snap => {
    renderMessage(snap.key, snap.val());
  });

  convoRef.on('child_changed', snap => {
    updateMessage(snap.key, snap.val());
  });
  }
  function confirmDeleteMessage(msgKey, msgObj) {
  const now = Date.now();
  const ageInMs = now - msgObj.ts;
  const oneMinute = 60 * 1000;

  const isPrivate = !currentChat.startsWith('group__');
  const isSender = msgObj.from === user;

  // Option 1: Too late
  if (ageInMs > oneMinute && isSender) {
    const confirmSelf = confirm("Message is older than 1 minute. Delete for you only?");
    if (confirmSelf) {
      // Just remove locally
      event.target.remove();
    }
    return;
  }

  // Option prompt
  let options = "Delete this message:\n1. For Me";
  if (isSender && ageInMs <= oneMinute) options += "\n2. For Everyone";

  const choice = prompt(options);
  if (!choice) return;

  if (choice === '1') {
    // Just delete visually
    event.target.remove();
  } else if (choice === '2' && isSender && ageInMs <= oneMinute) {
    let ref;
    if (isPrivate) {
      const convo = [user, currentChat].sort().join('_');
      ref = db.ref('privateChats/' + convo + '/' + msgKey);
    } else {
      const groupId = currentChat.split('__')[1];
      ref = db.ref('groupChats/' + groupId + '/' + msgKey);
    }

    ref.set({
      deleted: true,
      from: msgObj.from,
      ts: msgObj.ts
    });
  }
  }
  function renderMessage(key, m) {
  const div = document.createElement('div');
  div.setAttribute('data-key', key);

  if (m.deleted) {
    div.className = 'msg';
    div.style.fontStyle = 'italic';
    div.textContent = "Message deleted";
  } else {
    div.className = 'msg ' + (m.from === user ? 'you' : 'them');
    div.textContent = m.from === user && !currentChat.startsWith('group__') ? m.text : m.from + ": " + m.text;

    div.oncontextmenu = function (e) {
      e.preventDefault();
      confirmDeleteMessage(key, m);
    };
  }

  document.getElementById('messages').appendChild(div);
  document.getElementById('messages').scrollTop = 1e9;
}

function updateMessage(key, m) {
  const msgElement = document.querySelector(`[data-key="${key}"]`);
  if (!msgElement) return;

  if (m.deleted) {
    msgElement.className = 'msg';
    msgElement.style.fontStyle = 'italic';
    msgElement.textContent = "Message deleted";
  }
}
  function sendMsg() {
    const txt = document.getElementById('msgInput').value.trim();
    if (!txt || !currentChat) return;
    const msg = { from: user, text: txt, ts: Date.now() };
    if (currentChat.startsWith('group__')) {
      const g = currentChat.split('__')[1];
      db.ref('groupChats/' + g).push(msg);
    } else {
      const convo = [user, currentChat].sort().join('_');
      db.ref('privateChats/' + convo).push(msg);
    }
    document.getElementById('msgInput').value = '';
  }

  
  function closeChat() {
    document.getElementById('chatWindow').style.display = 'none';
    document.getElementById('chatHeader').style.display = 'none';
    document.getElementById('backBtn').style.display = 'none';
  }

  function logout() {
    localStorage.removeItem('username');
    location.href = 'index.html';
  }

  function openTab(id) {
  // Highlight the correct tab button
  document.querySelectorAll('.tabs button').forEach(b => {
    const targetId = b.textContent.trim().toLowerCase() + 'Content';
    b.classList.toggle('active', targetId === id);
  });

  // Show only the selected content section
  document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
  document.getElementById(id).classList.add('active');

  // Hide chat window when switching to Chats tab
  if (id === 'chatContent') {
    document.getElementById('chatWindow').style.display = 'none';
  }
  }
  function openChatOptions() {
  if (!currentChat) return;

  const isGroup = currentChat.startsWith('group__');
  const name = document.getElementById('chatWith').textContent;

  if (!isGroup) {
    // Private chat options
    let html = `User: ${name}\n\n1. Block User\n2. Delete Chat\n\nChoose option (1-2):`;
    const option = prompt(html);
    if (!option) return;

    if (option === '1') {
      alert(`${name} has been blocked (locally).`);
    } else if (option === '2') {
      const convo = [user, currentChat].sort().join('_');
      db.ref('privateChats/' + convo).remove();
      closeChat();
      alert("Chat deleted (for you only).");
    }
  } else {
    // Group chat options
    const groupId = currentChat.split('__')[1];
    db.ref('groups/' + groupId).once('value').then(snap => {
      const group = snap.val();
      if (!group) return;

      let html = `Group: ${group.name}\n`;

      if (!group.public) {
        html += `(Private group)\nPassword: ${group.password}\n`;
      }

      html += `\n1. View Members\n2. Leave Group\n3. Delete Chat\n\nChoose option (1-3):`;
      const option = prompt(html);
      if (!option) return;

      if (option === '1') {
        const members = Object.keys(group.members || {}).join(', ');
        alert("Group Members:\n" + members);
      } else if (option === '2') {
        db.ref('groups/' + groupId + '/members/' + user).remove();
        closeChat();
        alert("You have left the group.");
      } else if (option === '3') {
        closeChat();
        alert("Group chat deleted (for you only).");
      }
    });
  }
  }
</script>
<script>
let localStream, peer, remoteStreamRef;
const callUI = document.getElementById('callModal');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');

function startCall(type) {
  if (!currentChat || currentChat.startsWith('group__')) {
    return alert('Only private chats supported.');
  }

  navigator.mediaDevices.getUserMedia({ 
    video: type === 'video', 
    audio: true 
  }).then(stream => {
    localStream = stream;
    localVideo.srcObject = stream;

    peer = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
    localStream.getTracks().forEach(track => peer.addTrack(track, localStream));

    peer.ontrack = e => {
      if (!remoteStreamRef) {
        remoteStreamRef = new MediaStream();
        remoteVideo.srcObject = remoteStreamRef;
      }
      remoteStreamRef.addTrack(e.track);
    };

    peer.onicecandidate = e => {
      if (e.candidate) {
        db.ref(`calls/${currentChat}/ice`).push({ from: user, candidate: e.candidate });
      }
    };

    peer.createOffer().then(offer => {
<script>
const config = {
  apiKey: "AIzaSyBfkUJS81minjxj0DFz4pzNnGzCtb5ZJss",
  authDomain: "locater-42fb4.firebaseapp.com",
  databaseURL: "https://locater-42fb4-default-rtdb.firebaseio.com",
  projectId: "locater-42fb4",
  storageBucket: "locater-42fb4.appspot.com",
  messagingSenderId: "250348367998",
  appId: "1:250348367998:web:d734b2b4c735b5684ae82f"
};

firebase.initializeApp(config);
const db = firebase.database();
const user = localStorage.getItem('username') || prompt('Enter username');
localStorage.setItem('username', user);
document.getElementById('currentUser').textContent = user;
db.ref('users/' + user).set(true);

const map = L.map('map').setView([1.29, 36.82], 12);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
const markers = {};

setInterval(() => {
  navigator.geolocation.getCurrentPosition(pos => {
    db.ref('locations/' + user).set({ lat: pos.coords.latitude, lng: pos.coords.longitude });
  });
}, 5000);

db.ref('locations').on('value', snap => {
  const locs = snap.val() || {};
  for (const [u, loc] of Object.entries(locs)) {
    if (markers[u]) markers[u].setLatLng([loc.lat, loc.lng]);
    else markers[u] = L.marker([loc.lat, loc.lng]).addTo(map).bindPopup(u);
  }
});

const userList = document.getElementById('users');
const searchBox = document.getElementById('searchBox');
let allUsers = {}, allGroups = {}, currentChat = '', convoRef = null;

db.ref('users').on('value', snap => {
  allUsers = snap.val() || {};
  refreshUserList();
});

db.ref('groups').on('value', snap => {
  allGroups = snap.val() || {};
  refreshUserList();
});

searchBox.addEventListener('input', refreshUserList);
function refreshUserList() {
  const searchTerm = searchBox.value.toLowerCase();
  let html = `<h3 style="margin:10px 0 5px;">Users</h3>`;

  // Filter and display users
  Object.keys(allUsers).forEach(u => {
    if (u !== user && u.toLowerCase().includes(searchTerm)) {
      html += `<button onclick="openChat('${u}')">${u}</button>`;
    }
  });

  html += `<h3 style="margin:15px 0 5px;">Groups</h3>`;

  // Filter and display groups
  Object.entries(allGroups).forEach(([id, data]) => {
    if (!data || typeof data.name !== 'string') return;

    const groupName = data.name.toLowerCase();
    if (groupName.includes(searchTerm)) {
      const label = data.public ? `# ${data.name}` : `ðŸ”’ ${data.name}`;
      html += `<button class="group" onclick="attemptJoinGroup('${id}', '${data.name}')">${label}</button>`;
    }
  });

  userList.innerHTML = html;
}
function createGroup() {
  let name = prompt("Enter group name (no special characters):");
  if (!name) return;
  name = name.trim().replace(/[^a-zA-Z0-9 -]/g, '').replace(/\s+/g, '');

  let type = prompt("Group Type: Type 'public' or 'private'").toLowerCase();
  if (type !== 'public' && type !== 'private') return alert("Invalid group type.");
  const isPublic = type === 'public';
  let password = null;

  if (!isPublic) {
    password = prompt("Enter password:");
    if (!password) return alert("Private group must have a password.");
  }

  const groupData = {
    name,
    admin: user,
    public: isPublic,
    password: isPublic ? null : password,
    members: { [user]: true }
  };

  const newRef = db.ref('groups').push();
  newRef.set(groupData, err => {
    if (!err) {
      db.ref('groupChats/' + newRef.key).push({
        from: 'System',
        text: `${user} created this ${type} group.`,
        ts: Date.now()
      });
      alert(`${type.charAt(0).toUpperCase() + type.slice(1)} group created!`);
    }
  });
}

function attemptJoinGroup(groupId, groupName) {
  db.ref('groups/' + groupId).once('value').then(snap => {
    const group = snap.val();
    if (!group) return;

    if (group.members && group.members[user]) {
      openGroup(groupId, groupName);
    } else if (!group.public) {
      const pwd = prompt("Private group. Enter password:");
      if (pwd === group.password) {
        const join = confirm("Correct password. Join group?");
        if (join) {
          db.ref('groups/' + groupId + '/members/' + user).set(true);
          openGroup(groupId, groupName);
        }
      } else {
        alert("Wrong password.");
      }
    } else {
      const join = confirm("Join this public group?");
      if (join) {
        db.ref('groups/' + groupId + '/members/' + user).set(true);
        openGroup(groupId, groupName);
      }
    }
  });
}

function openChat(other) {
  currentChat = other;
  document.getElementById('chatWith').innerHTML = `<span onclick="openChatOptions()" style="cursor:pointer; text-decoration:underline;">${other}</span>`;
  document.getElementById('chatWindow').style.display = 'flex';
  document.getElementById('chatHeader').style.display = 'flex';
  document.getElementById('messages').innerHTML = '';
  if (convoRef) convoRef.off();
  const convo = [user, other].sort().join('_');
  convoRef = db.ref('privateChats/' + convo);

  convoRef.on('child_added', snap => renderMessage(snap.key, snap.val()));
  convoRef.on('child_changed', snap => updateMessage(snap.key, snap.val()));
}

function openGroup(groupId, displayName) {
  currentChat = 'group__' + groupId;
  document.getElementById('chatWith').innerHTML = `<span onclick="openChatOptions()" style="cursor:pointer; text-decoration:underline;">#${displayName}</span>`;
  document.getElementById('chatWindow').style.display = 'flex';
  document.getElementById('chatHeader').style.display = 'flex';
  document.getElementById('messages').innerHTML = '';
  if (window.innerWidth <= 600) document.getElementById('backBtn').style.display = 'inline-block';
  if (convoRef) convoRef.off();
  convoRef = db.ref('groupChats/' + groupId);

  convoRef.on('child_added', snap => renderMessage(snap.key, snap.val()));
  convoRef.on('child_changed', snap => updateMessage(snap.key, snap.val()));
}

function renderMessage(key, m) {
  const div = document.createElement('div');
  div.setAttribute('data-key', key);
  if (m.deleted) {
    div.className = 'msg';
    div.style.fontStyle = 'italic';
    div.textContent = "Message deleted";
  } else {
    div.className = 'msg ' + (m.from === user ? 'you' : 'them');
    div.textContent = m.from === user && !currentChat.startsWith('group__') ? m.text : m.from + ": " + m.text;
    div.oncontextmenu = function (e) {
      e.preventDefault();
      confirmDeleteMessage(key, m);
    };
  }
  document.getElementById('messages').appendChild(div);
  document.getElementById('messages').scrollTop = 1e9;
}

function updateMessage(key, m) {
  const msgElement = document.querySelector(`[data-key="${key}"]`);
  if (!msgElement) return;
  if (m.deleted) {
    msgElement.className = 'msg';
    msgElement.style.fontStyle = 'italic';
    msgElement.textContent = "Message deleted";
  }
}

function sendMsg() {
  const txt = document.getElementById('msgInput').value.trim();
  if (!txt || !currentChat) return;
  const msg = { from: user, text: txt, ts: Date.now() };
  if (currentChat.startsWith('group__')) {
    const g = currentChat.split('__')[1];
    db.ref('groupChats/' + g).push(msg);
  } else {
    const convo = [user, currentChat].sort().join('_');
    db.ref('privateChats/' + convo).push(msg);
  }
  document.getElementById('msgInput').value = '';
}

function closeChat() {
  document.getElementById('chatWindow').style.display = 'none';
  document.getElementById('chatHeader').style.display = 'none';
  document.getElementById('backBtn').style.display = 'none';
}

function logout() {
  localStorage.removeItem('username');
  location.href = 'index.html';
}

function openTab(id) {
  document.querySelectorAll('.tabs button').forEach(b => {
    const targetId = b.textContent.trim().toLowerCase() + 'Content';
    b.classList.toggle('active', targetId === id);
  });
  document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  if (id === 'chatContent') {
    document.getElementById('chatWindow').style.display = 'none';
  }
}

function confirmDeleteMessage(msgKey, msgObj) {
  const now = Date.now();
  const age = now - msgObj.ts;
  const isPrivate = !currentChat.startsWith('group__');
  const isSender = msgObj.from === user;

  if (age > 60000 && isSender) {
    if (confirm("Delete for you only?")) event.target.remove();
    return;
  }

  const choice = prompt("Delete this message:\n1. For Me" + (isSender ? "\n2. For Everyone" : ""));
  if (choice === '1') event.target.remove();
  else if (choice === '2' && isSender && age <= 60000) {
    const ref = isPrivate
      ? db.ref('privateChats/' + [user, currentChat].sort().join('_') + '/' + msgKey)
      : db.ref('groupChats/' + currentChat.split('__')[1] + '/' + msgKey);
    ref.set({ deleted: true, from: msgObj.from, ts: msgObj.ts });
  }
}

function openChatOptions() {
  if (!currentChat) return;
  const isGroup = currentChat.startsWith('group__');
  const name = document.getElementById('chatWith').textContent;
  let option = prompt(isGroup
    ? `Group: ${name}\n1. View Members\n2. Leave Group\n3. Delete Chat`
    : `User: ${name}\n1. Block User\n2. Delete Chat`);
  if (!option) return;

  const groupId = currentChat.split('__')[1];
  if (!isGroup) {
    if (option === '1') alert(`${name} blocked locally.`);
    else if (option === '2') {
      db.ref('privateChats/' + [user, currentChat].sort().join('_')).remove();
      closeChat();
    }
  } else {
    if (option === '1') {
      db.ref('groups/' + groupId + '/members').once('value').then(snap => {
        alert("Members:\n" + Object.keys(snap.val() || {}).join(', '));
      });
    } else if (option === '2') {
      db.ref('groups/' + groupId + '/members/' + user).remove();
      closeChat();
    } else if (option === '3') {
      closeChat();
    }
  }
}
<script>
let localStream, peer, remoteStreamRef;
const callUI = document.getElementById('callModal');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');

function startCall(type) {
  if (!currentChat || currentChat.startsWith('group__')) {
    return alert('Only private chats supported.');
  }

  navigator.mediaDevices.getUserMedia({ 
    video: type === 'video', 
    audio: true 
  }).then(stream => {
    localStream = stream;
    localVideo.srcObject = stream;

    peer = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    stream.getTracks().forEach(track => peer.addTrack(track, stream));

    peer.ontrack = e => {
      if (!remoteStreamRef) {
        remoteStreamRef = new MediaStream();
        remoteVideo.srcObject = remoteStreamRef;
      }
      remoteStreamRef.addTrack(e.track);
    };

    peer.onicecandidate = e => {
      if (e.candidate) {
        db.ref(`calls/${currentChat}/ice`).push({ from: user, candidate: e.candidate });
      }
    };

    peer.createOffer().then(offer => {
      peer.setLocalDescription(offer);
      db.ref(`calls/${currentChat}/signal`).set({
        from: user,
        to: currentChat,
        type,
        offer: JSON.stringify(offer)
      });
    });

    callUI.style.display = 'flex';
  });
}

function endCall() {
  if (peer) peer.close();
  if (localStream) localStream.getTracks().forEach(t => t.stop());

  localVideo.srcObject = null;
  remoteVideo.srcObject = null;
  callUI.style.display = 'none';

  if (currentChat) {
    db.ref(`calls/${currentChat}/signal`).remove();
    db.ref(`calls/${currentChat}/ice`).remove();
  }
}
  window.startCall = startCall;
  window.endCall = endCall;

// Handle incoming call offer
db.ref(`calls/${user}/signal`).on('value', snap => {
  const data = snap.val();
  if (!data || data.from === user) return;

  const accept = confirm(`${data.from} is calling (${data.type}). Accept?`);
  if (!accept) return;

  navigator.mediaDevices.getUserMedia({
    video: data.type === 'video',
    audio: true
  }).then(stream => {
    localStream = stream;
    localVideo.srcObject = stream;

    peer = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    stream.getTracks().forEach(track => peer.addTrack(track, stream));

    peer.ontrack = e => {
      if (!remoteStreamRef) {
        remoteStreamRef = new MediaStream();
        remoteVideo.srcObject = remoteStreamRef;
      }
      remoteStreamRef.addTrack(e.track);
    };

    peer.onicecandidate = e => {
      if (e.candidate) {
        db.ref(`calls/${data.from}/ice`).push({ from: user, candidate: e.candidate });
      }
    };

    const offer = JSON.parse(data.offer);
    peer.setRemoteDescription(new RTCSessionDescription(offer)).then(() => {
      return peer.createAnswer();
    }).then(answer => {
      peer.setLocalDescription(answer);
      db.ref(`calls/${data.from}/signal/answer`).set(JSON.stringify(answer));
    });

    callUI.style.display = 'flex';
  });
});

// Handle ICE candidates
db.ref(`calls/${user}/ice`).on('child_added', snap => {
  const ice = snap.val();
  if (ice && peer && ice.from !== user) {
    peer.addIceCandidate(new RTCIceCandidate(ice.candidate));
  }
});

// Handle answer
db.ref(`calls/${currentChat}/signal/answer`).on('value', snap => {
  const ans = snap.val();
  if (ans && peer) {
    peer.setRemoteDescription(new RTCSessionDescription(JSON.parse(ans)));
  }
});
</script>
<script>
  window.addEventListener('beforeunload', function () {
  localStorage.removeItem('username');
});

window.addEventListener('unload', function () {
  localStorage.removeItem('username');
});
</script>
</html>
