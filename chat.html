<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WhatsApp Clone</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>
</head>
<body class="flex h-screen overflow-hidden bg-white dark:bg-gray-900 text-black dark:text-white">
  <!-- Chat List Sidebar -->
  <aside id="chatList" class="w-full md:w-1/3 lg:w-1/4 border-r border-gray-300 overflow-y-auto md:block hidden">
    <div class="flex justify-between items-center p-4 border-b">
      <h2 class="text-xl font-bold">Chats</h2>
      <button id="createGroupBtn" class="text-sm text-blue-600 hover:underline">+ Group</button>
    </div>
    <ul id="userList" class="divide-y"></ul>
  </aside>

  <!-- Chat Window -->
  <main id="chatWindow" class="flex-1 flex flex-col hidden md:flex">
    <!-- Chat Header -->
    <div id="chatHeader" class="flex items-center justify-between px-4 py-2 border-b bg-gray-50">
      <div class="flex items-center gap-2">
        <button id="backBtn" class="md:hidden text-blue-600 pr-2">&larr;</button>
        <div>
          <h2 id="chatName" class="text-lg font-semibold"></h2>
          <p id="chatStatus" class="text-sm text-gray-500"></p>
        </div>
      </div>
      <button id="closeChat" class="text-red-600 hover:underline">Close</button>
      <button id="toggleTheme" class="text-sm text-gray-600 hover:text-black">ðŸŒ“</button>
      <input id="searchInput" type="text" placeholder="Search messages..." class="border px-2 py-1 rounded text-sm hidden md:inline-block" />
      <button id="blockUser" class="text-sm text-red-500">ðŸš« Block</button>
    </div>


    <!-- Messages -->
    <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-2 bg-white"></div>

    <!-- Typing Indicator -->
    <div id="typing" class="text-sm text-gray-400 px-4 py-1 hidden">Typing...</div>

    <!-- Message Input -->
    <form id="messageForm" class="flex items-center p-2 border-t gap-2 bg-gray-50">
      <input id="messageInput" type="text" placeholder="Type a message" class="flex-1 border px-3 py-2 rounded" />
      <input type="file" id="fileInput" class="hidden" />
      <button type="button" id="attachBtn" class="text-blue-600">ðŸ“Ž</button>
      <button type="submit" class="bg-blue-600 text-white px-4 py-2 rounded">Send</button>
    </form>
    <!-- Call UI -->
<div id="callControls" class="fixed bottom-4 right-4 flex flex-col space-y-2">
  <button id="audioCallBtn" class="bg-green-500 text-white px-4 py-2 rounded shadow">ðŸ“ž Audio</button>
  <button id="videoCallBtn" class="bg-blue-600 text-white px-4 py-2 rounded shadow">ðŸŽ¥ Video</button>
</div>

<!-- Call Modal -->
<div id="callModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50">
  <div class="bg-white p-6 rounded-lg text-center space-y-4">
    <h3 id="callTitle" class="text-xl font-bold">Calling...</h3>
    <video id="remoteVideo" autoplay playsinline class="w-full h-64 bg-black rounded"></video>
    <video id="localVideo" autoplay playsinline muted class="w-24 h-24 rounded-full absolute bottom-4 right-4"></video>
    <button id="endCallBtn" class="bg-red-600 text-white px-4 py-2 rounded">End Call</button>
  </div>
</div>

  </main>

  <!-- Group Modal (Hidden by Default) -->
  <div id="groupModal" class="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center hidden">
    <div class="bg-white p-4 rounded-lg w-96 space-y-4">
      <h3 class="text-lg font-bold">Create Group</h3>
      <input type="text" id="groupName" class="w-full border px-3 py-2 rounded" placeholder="Group Name" />
      <div id="groupUsers" class="max-h-40 overflow-y-auto space-y-2"></div>
      <button id="createGroup" class="bg-blue-600 text-white px-4 py-2 rounded">Create</button>
      <button id="closeModal" class="text-sm text-gray-500 hover:underline">Cancel</button>
    </div>
  </div>

  <script src="chat.js"></script>
<script>
// Firebase config (replace with your own)
const firebaseConfig = {
      apiKey: "AIzaSyBfkUJS81minjxj0DFz4pzNnGzCtb5ZJss",
      authDomain: "locater-42fb4.firebaseapp.com",
      databaseURL: "https://locater-42fb4-default-rtdb.firebaseio.com",
      projectId: "locater-42fb4",
      storageBucket: "locater-42fb4.appspot.com",
      messagingSenderId: "250348367998",
      appId: "1:250348367998:web:d734b2b4c735b5684ae82f"
    };

firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const storage = firebase.storage();

const currentUser = sessionStorage.getItem("username");
if (!currentUser) location.href = "index.html";

const userList = document.getElementById("userList");
const messagesEl = document.getElementById("messages");
const chatHeader = document.getElementById("chatHeader");
const chatName = document.getElementById("chatName");
const chatStatus = document.getElementById("chatStatus");
const messageForm = document.getElementById("messageForm");
const messageInput = document.getElementById("messageInput");
const attachBtn = document.getElementById("attachBtn");
const fileInput = document.getElementById("fileInput");
const typingEl = document.getElementById("typing");

let selectedChat = null;
let typingTimer;

if ("Notification" in window && Notification.permission !== "granted") {
  Notification.requestPermission();
}

// Load Users and Groups
db.ref("users").on("value", snapshot => {
  userList.innerHTML = "";
  snapshot.forEach(child => {
    const username = child.key;
    if (username === currentUser) return;
    const li = document.createElement("li");
    li.className = "p-3 hover:bg-gray-100 cursor-pointer";
    li.textContent = username;
    li.onclick = () => openChat(username, false);
    userList.appendChild(li);
  });
});


  db.ref("groups").on("child_added", snap => {
    const group = snap.val();
    if (!group.members || !group.members[currentUser]) return;
    const li = document.createElement("li");
    li.className = "p-3 hover:bg-gray-100 cursor-pointer text-green-600";
    li.textContent = `# ${group.name}`;
    li.onclick = () => openChat(group.id, true);
    userList.appendChild(li);
  });
}
const searchInput = document.getElementById("searchInput");

searchInput.oninput = () => {
  const query = searchInput.value.toLowerCase();
  const messages = messagesEl.querySelectorAll("div[data-id]");
  messages.forEach(m => {
    const match = m.textContent.toLowerCase().includes(query);
    m.style.display = match ? "" : "none";
  });
};

const chatListEl = document.getElementById("chatList");
const chatWindowEl = document.getElementById("chatWindow");
const backBtn = document.getElementById("backBtn");

function openChat(id, isGroup = false) {
  // ... your existing code ...
  chatListEl.classList.add("hidden");
  chatWindowEl.classList.remove("hidden");
}

backBtn.onclick = () => {
  chatListEl.classList.remove("hidden");
  chatWindowEl.classList.add("hidden");
};

// Open Chat
function openChat(id, isGroup = false) {
  selectedChat = { id, isGroup };
  messagesEl.innerHTML = "";
  chatName.textContent = isGroup ? `# ${id}` : id;
  chatStatus.textContent = isGroup ? "Group" : "Loading...";

  if (!isGroup) {
    db.ref(`users/${id}/lastSeen`).on("value", snap => {
      const val = snap.val();
      if (!val) return;
      chatStatus.textContent = `last seen ${new Date(val).toLocaleTimeString()}`;
    });
  }

  db.ref(getChatPath()).off(); // remove old listener
  db.ref(getChatPath()).on("child_added", snap => {
    const msg = snap.val();
    renderMessage(msg, snap.key);
  });
}

function getChatPath() {
  if (!selectedChat) return "";
  if (selectedChat.isGroup) return `groupMessages/${selectedChat.id}`;
  const ids = [currentUser, selectedChat.id].sort();
  return `messages/${ids[0]}_${ids[1]}`;
}

function renderMessage(msg, id) {
  const div = document.createElement("div");
  div.dataset.id = id;
  div.className = `relative max-w-xs px-4 py-2 rounded shadow text-sm break-words ${
    msg.sender === currentUser ? "bg-blue-100 ml-auto" : "bg-gray-100"
  }`;
  div.innerHTML = msg.text || (msg.fileUrl ? `<a href="${msg.fileUrl}" target="_blank">ðŸ“Ž ${msg.fileName}</a>` : "");

  const ticks = document.createElement("span");
  ticks.className = "absolute bottom-1 right-2 text-xs";
  if (msg.reactions) {
  const reactionBar = document.createElement("div");
  reactionBar.className = "text-sm mt-1";
  for (const [user, emoji] of Object.entries(msg.reactions)) {
    const span = document.createElement("span");
    span.textContent = emoji;
    reactionBar.appendChild(span);
  }
  div.appendChild(reactionBar);
}

  if (msg.sender === currentUser) {
    if (msg.status === "read") {
      ticks.textContent = "âœ“âœ“";
      ticks.classList.add("text-blue-500");
    } else if (msg.status === "delivered") {
      ticks.textContent = "âœ“âœ“";
    } else {
      ticks.textContent = "âœ“";
    }
    div.appendChild(ticks);

    const del = document.createElement("span");
    del.textContent = " âŒ";
    del.className = "cursor-pointer ml-2 text-red-500";
    del.onclick = () => deleteMessage(id);
    div.appendChild(del);
  } else {
    // Mark as read if you're the recipient
    if (!selectedChat.isGroup) {
      db.ref(`${getChatPath()}/${id}/status`).set("read");
    }
  }
  if (msg.sender !== currentUser && document.hidden) {
  new Notification(`New message from ${msg.sender}`, {
    body: msg.text,
    icon: "/assets/whatsapp-icon.png"
  });
}

  messagesEl.appendChild(div);
  messagesEl.scrollTop = messagesEl.scrollHeight;
  if (msg.sender === currentUser && !msg.deleted) {
  const edit = document.createElement("span");
  edit.textContent = " âœï¸";
  edit.className = "cursor-pointer ml-2 text-blue-500";
  edit.onclick = () => editMessage(id, msg.text);
  div.appendChild(edit);
  let startX = null;

div.addEventListener("touchstart", e => {
  startX = e.touches[0].clientX;
});

div.addEventListener("touchend", e => {
  if (!startX) return;
  const endX = e.changedTouches[0].clientX;
  const deltaX = endX - startX;
  if (deltaX > 80 && msg.sender !== currentUser) {
    quoteMessage(msg.text); // trigger reply
  }
  startX = null;
});

}
  const reply = document.createElement("span");
reply.textContent = " â†©ï¸";
reply.className = "cursor-pointer ml-2 text-green-500";
reply.onclick = () => quoteMessage(msg.text);
div.appendChild(reply);
const star = document.createElement("span");
star.textContent = " â­";
star.className = "cursor-pointer ml-2 text-yellow-500";
star.onclick = () => toggleStar(id, msg);
div.appendChild(star);
const react = document.createElement("span");
react.textContent = " ðŸ˜Š";
react.className = "cursor-pointer ml-2";
react.onclick = () => addReaction(id);
div.appendChild(react);

}


// Send Message
db.ref(`blocked/${selectedChat.id}/${currentUser}`).once("value", snap => {
  if (snap.exists()) {
    alert("You are blocked by this user.");
    return;
  }
  let quoteText = "";

function quoteMessage(text) {
  quoteText = text;
  messageInput.value = `> ${text}\n`;
  messageInput.focus();
}

messageForm.onsubmit = async e => {
  e.preventDefault();
  const text = messageInput.value.trim();
  if (!text || !selectedChat) return;

  const msg = {
    sender: currentUser,
    text,
    timestamp: Date.now(),
    status: "sent"
  };

  const ref = db.ref(getChatPath()).push();
  await ref.set(msg);

  // Set delivered status immediately for group or if user is online
  if (!selectedChat.isGroup) {
    const recipientStatusRef = db.ref(`users/${selectedChat.id}/online`);
    recipientStatusRef.once("value", snap => {
      if (snap.val()) {
        ref.update({ status: "delivered" });
      }
    });
  }

  messageInput.value = "";
  sendTyping(false);
const msg = {
  sender: currentUser,
  text: quoteText ? `${quoteText}\n\n${text}` : text,
  timestamp: Date.now(),
  status: "sent"
};
quoteText = ""; // Clear quote

};


});


// Typing Indicator
messageInput.oninput = () => {
  sendTyping(true);
  clearTimeout(typingTimer);
  typingTimer = setTimeout(() => sendTyping(false), 2000);
};

function sendTyping(isTyping) {
  if (!selectedChat || selectedChat.isGroup) return;
  db.ref(`typing/${selectedChat.id}`).set(isTyping ? currentUser : "");
}

db.ref(`typing/${currentUser}`).on("value", snap => {
  const typer = snap.val();
  typingEl.classList.toggle("hidden", !typer);
  if (typer) typingEl.textContent = `${typer} is typing...`;
});

// File Attachments
attachBtn.onclick = () => fileInput.click();
fileInput.onchange = async () => {
  const file = fileInput.files[0];
  if (!file) return;
  const ref = storage.ref().child(`attachments/${Date.now()}_${file.name}`);
  await ref.put(file);
  const url = await ref.getDownloadURL();

  const msg = {
    sender: currentUser,
    fileUrl: url,
    fileName: file.name,
    timestamp: Date.now()
  };

  await db.ref(getChatPath()).push(msg);
};

// Delete Message (basic, for user only)
function deleteMessage(id) {
  const msgRef = db.ref(`${getChatPath()}/${id}`);
  msgRef.once("value", snap => {
    const msg = snap.val();
    if (!msg) return;

    const timeElapsed = Date.now() - msg.timestamp;
    const canDeleteForEveryone = msg.sender === currentUser && timeElapsed <= 60000;

    const confirmText = canDeleteForEveryone
      ? "Delete for everyone or just for you?"
      : "Delete for me only?";

    const option = confirm(confirmText);

    if (option && canDeleteForEveryone) {
      // Mark as deleted for everyone
      msgRef.update({
        text: "ðŸš« This message was deleted.",
        fileUrl: null,
        fileName: null,
        deleted: true
      });
    } else {
      // Delete just for current user (local removal only)
      const bubble = document.querySelector(`[data-id="${id}"]`);
      if (bubble) bubble.remove();
    }
  });
}

// Close Chat
document.getElementById("closeChat").onclick = () => {
  selectedChat = null;
  chatName.textContent = "";
  chatStatus.textContent = "";
  messagesEl.innerHTML = "";
};

// Group Modal Logic
document.getElementById("createGroupBtn").onclick = () => {
  document.getElementById("groupModal").classList.remove("hidden");
  const groupUsers = document.getElementById("groupUsers");
  groupUsers.innerHTML = "";
  db.ref("users").once("value", snap => {
    snap.forEach(child => {
      const user = child.val();
      if (user.username === currentUser) return;
      const checkbox = document.createElement("div");
      checkbox.innerHTML = `<label><input type="checkbox" value="${user.username}" /> ${user.username}</label>`;
      groupUsers.appendChild(checkbox);
    });
  });
};

document.getElementById("closeModal").onclick = () => {
  document.getElementById("groupModal").classList.add("hidden");
};

document.getElementById("createGroup").onclick = () => {
  const name = document.getElementById("groupName").value.trim();
  if (!name) return alert("Enter group name");

  const checkboxes = document.querySelectorAll("#groupUsers input:checked");
  const members = Array.from(checkboxes).map(cb => cb.value);
  members.push(currentUser);

  const groupId = `${name}_${Date.now()}`;
  db.ref(`groups/${groupId}`).set({ id: groupId, name, members });
  document.getElementById("groupModal").classList.add("hidden");
};

// Update Last Seen on exit
window.addEventListener("beforeunload", () => {
  db.ref(`users/${currentUser}/lastSeen`).set(Date.now());
});

// Load users and start
loadUsers();
// Mark current user online
db.ref(`users/${currentUser}/online`).set(true);
db.ref(`users/${currentUser}/online`).onDisconnect().set(false);
db.ref(`users/${currentUser}/lastSeen`).onDisconnect().set(Date.now());
function editMessage(id, oldText) {
  const newText = prompt("Edit message:", oldText);
  if (newText && newText.trim() && newText !== oldText) {
    db.ref(`${getChatPath()}/${id}`).update({
      text: newText + " (edited)"
    });
  }
}
const audioCallBtn = document.getElementById("audioCallBtn");
const videoCallBtn = document.getElementById("videoCallBtn");
const callModal = document.getElementById("callModal");
const callTitle = document.getElementById("callTitle");
const endCallBtn = document.getElementById("endCallBtn");
const localVideo = document.getElementById("localVideo");
const remoteVideo = document.getElementById("remoteVideo");

let pc = null;
let localStream = null;
let remoteStream = null;
let isCaller = false;

const servers = {
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" }
  ]
};

audioCallBtn.onclick = () => startCall(false);
videoCallBtn.onclick = () => startCall(true);

async function startCall(withVideo) {
  if (!selectedChat || selectedChat.isGroup) return alert("Calls only work in 1-on-1 chats");

  isCaller = true;
  callModal.classList.remove("hidden");
  callTitle.textContent = "Calling...";

  localStream = await navigator.mediaDevices.getUserMedia({
    video: withVideo,
    audio: true
  });

  localVideo.srcObject = localStream;

  setupPeer();

  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  const callRef = db.ref(`calls/${selectedChat.id}`);
  callRef.set({
    from: currentUser,
    offer: JSON.stringify(offer),
    video: withVideo
  });

  callRef.on("value", async snap => {
    const data = snap.val();
    if (!data || data.from === currentUser) return;

    if (data.answer && !pc.remoteDescription) {
      await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(data.answer)));
    }

    if (data.candidate) {
      try {
        await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(data.candidate)));
      } catch (e) {
        console.error("ICE Error", e);
      }
    }
  });
}
const callLog = {
  with: selectedChat.id,
  type: withVideo ? "video" : "audio",
  time: Date.now(),
  direction: "outgoing"
};
db.ref(`callsHistory/${currentUser}`).push(callLog);

function setupPeer() {
  pc = new RTCPeerConnection(servers);

  remoteStream = new MediaStream();
  remoteVideo.srcObject = remoteStream;

  pc.ontrack = event => {
    remoteStream.addTrack(event.track);
  };

  pc.onicecandidate = event => {
    if (event.candidate) {
      const ref = db.ref(`calls/${isCaller ? selectedChat.id : currentUser}`);
      ref.update({
        candidate: JSON.stringify(event.candidate)
      });
    }
  };
}

// Incoming Call Listener
db.ref(`calls/${currentUser}`).on("value", async snap => {
  const data = snap.val();
  if (!data || data.from === currentUser) return;

  if (!confirm(`${data.from} is calling you. Accept?`)) return;

  callModal.classList.remove("hidden");
  callTitle.textContent = `In call with ${data.from}`;

  localStream = await navigator.mediaDevices.getUserMedia({
    video: data.video,
    audio: true
  });

  localVideo.srcObject = localStream;

  setupPeer();

  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(data.offer)));

  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  db.ref(`calls/${currentUser}`).update({
    answer: JSON.stringify(answer)
  });
  const incomingLog = {
  with: data.from,
  type: data.video ? "video" : "audio",
  time: Date.now(),
  direction: "incoming"
};
db.ref(`callsHistory/${currentUser}`).push(incomingLog);

});

// End Call
endCallBtn.onclick = () => {
  callModal.classList.add("hidden");
  if (pc) pc.close();
  if (localStream) localStream.getTracks().forEach(t => t.stop());
  db.ref(`calls/${currentUser}`).remove();
  db.ref(`calls/${selectedChat?.id}`).remove();
};
const toggleThemeBtn = document.getElementById("toggleTheme");

toggleThemeBtn.onclick = () => {
  document.documentElement.classList.toggle("dark");
  localStorage.setItem("theme", document.documentElement.classList.contains("dark") ? "dark" : "light");
};

// Apply theme on load
if (localStorage.getItem("theme") === "dark") {
  document.documentElement.classList.add("dark");
}
function toggleStar(id, msg) {
  const ref = db.ref(`stars/${currentUser}/${id}`);
  ref.once("value", snap => {
    if (snap.exists()) {
      ref.remove();
    } else {
      ref.set({
        ...msg,
        chatId: getChatPath()
      });
    }
  });
}
db.ref(`stars/${currentUser}`).once("value", snap => {
  snap.forEach(child => {
    renderMessage(child.val(), child.key);
  });
});
function addReaction(msgId) {
  const emoji = prompt("React with emoji:");
  if (!emoji) return;
  db.ref(`${getChatPath()}/${msgId}/reactions/${currentUser}`).set(emoji);
}
db.ref(`callsHistory/${currentUser}`).once("value", snap => {
  snap.forEach(child => {
    const log = child.val();
    console.log(`[${log.direction}] ${log.with} - ${log.type}`);
  });
});
document.getElementById("blockUser").onclick = () => {
  if (!selectedChat || selectedChat.isGroup) return;
  db.ref(`blocked/${currentUser}/${selectedChat.id}`).set(true);
};

</script>
</body>
</html>
