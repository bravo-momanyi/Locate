<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CHAT AND CONNECT</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>
  <style>
    html, body { width: 100vw; height: 100vh; min-width: 0; overflow: hidden; }
    #mainContainer { display: flex; width: 100vw; height: 100vh; }
    #sidebar {
      width: 320px; min-width: 220px; max-width: 400px;
      background: #f3f4f6; border-right: 1px solid #d1d5db;
      display: flex; flex-direction: column; height: 100vh; overflow-y: auto;
      transition: width 0.25s;
    }
    #chatArea {
      flex: 1; min-width: 0; background: #fff;
      display: flex; flex-direction: column; height: 100vh;
      position: relative;
      transition: width 0.25s;
    }
    #chatHeader {
      position: sticky; top: 0; z-index: 40;
      background: #f3f4f6; border-bottom: 1px solid #d1d5db;
      display: flex; align-items: center; justify-content: space-between;
      padding: 0.5rem 1rem; min-height: 56px;
      flex-wrap: wrap;
    }
    #chatTitle { font-size: 1.15rem; font-weight: bold; color: #065f46; cursor:pointer; text-decoration:underline; }
    #chatSearchBar {
      border-radius: 6px; background: #fff; border: 1px solid #d1d5db;
      padding: 0.25rem 0.75rem; font-size: 1rem; min-width: 160px;
      margin-left:16px;
    }
    #onlineLastSeenIndicator {
      font-size: 0.95em;
      margin-left: 8px;
      color: #059669;
      font-weight: bold;
    }
    #typingIndicator {
      display: inline-block;
      margin-left: 8px;
      color: #065f46;
      font-style: italic;
      font-size: 1.1em;
      vertical-align: middle;
      min-width: 30px;
    }
    #tagReplyBar {
      position: sticky;
      bottom: 60px;
      left: 0;
      right: 0;
      z-index: 41;
    }
    .input-tag-bar {
      background: #e2e8f0;
      padding: 3px 8px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 2px;
      color: #065f46;
      font-size: 0.94em;
    }
    .input-tag-bar .remove-tag {
      color: #e53e3e;
      font-weight: bold;
      cursor: pointer;
      font-size: 1.2em;
    }
    .reply-tag {
      background: #e2e8f0;
      border-radius: 6px;
      margin-bottom: 2px;
      padding: 2px 8px;
      color: #065f46;
      display: block;
      font-size: 0.88em;
      cursor: pointer;
      border-left: 3px solid #3182ce;
    }
    #messages { flex: 1; overflow-y: auto; padding: 1rem; background: #fff; }
    #messageForm { position: sticky; bottom: 0; background: #f3f4f6; }
    .msg-light { background-color: #d4f8e8 !important; color: #222 !important; }
    .msg-dark { background-color: #065f46 !important; color: #fff !important; }
    .msg-edit { border: 1px solid #60a5fa; background-color: #f0faff; }
    #contextMenu { min-width: 180px; background: white; border: 1px solid #ddd; position: fixed; z-index: 9999; box-shadow: 0 2px 20px rgba(0,0,0,0.12);}
    #groupInfoModal { position:fixed; top:0; left:0; right:0; bottom:0; z-index:99999; background:rgba(0,0,0,0.14); display:none; align-items:center; justify-content:center;}
    #groupInfoContent { background:#fff; padding:2rem; border-radius:0.75rem; min-width:320px; max-width:90vw; }
    .date-sticky {
      position: sticky;
      top: 56px;
      z-index: 10;
      background: #e2e8f0;
      text-align: center;
      padding: 4px 0 4px 0;
      border-radius: 8px;
      font-size: 0.95rem;
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: #065f46;
    }
    .typing-dots {
      display: inline-block;
      vertical-align: middle;
      width: 32px;
      height: 18px;
    }
    .typing-dots span {
      display: inline-block;
      width: 6px;
      height: 6px;
      margin: 0 2px;
      background: #059669;
      border-radius: 50%;
      opacity: 0.7;
      animation: typing-dot 1.4s infinite both;
    }
    .typing-dots span:nth-child(2) { animation-delay: .2s; }
    .typing-dots span:nth-child(3) { animation-delay: .4s; }
    @keyframes typing-dot {
      0%, 80%, 100% { opacity: 0.2; transform: scale(0.8);}
      40% { opacity: 1; transform: scale(1.2);}
    }
    @media (max-width:768px) {
      #sidebar { width: 100vw; min-width: 0; max-width: 100vw; position: absolute; left: 0; top: 0; bottom: 0; z-index: 40; }
      #mainContainer { flex-direction: column; }
      #chatArea { width: 100vw; min-width: 0; }
      #sidebar.hide { display: none !important; }
      #chatArea.hide { display: none !important; }
      #chatHeader { position: sticky; top: 0; left: 0; width: 100vw; }
      #groupInfoContent { min-width: 90vw;}
      #messageForm { position:fixed; bottom:0; left:0; right:0; width:100vw; }
      #messages { margin-bottom:110px; }
      #tagReplyBar { position:fixed; bottom:60px; left:0; right:0; width:100vw; }
    }
    body.dark, body.dark #sidebar, body.dark #chatArea, body.dark #chatHeader, body.dark #messageForm {
      background: #222 !important; color: #fff !important;
    }
    .copy-btn { color:#065f46; background:#d4f8e8; border-radius:6px; padding:2px 8px; font-size:15px; margin-left:3px;}
    .copy-btn:hover { background:#065f46; color:#fff;}
    .badge { font-size: 0.9em; background: #e3e3e3; border-radius: 6px; padding: 2px 8px; margin-left:6px;}
    .badge-green { background:#d1fae5; color:#065f46; }
    .badge-blue { background:#bfdbfe; color:#2563eb; }
    .badge-gray { background:#e5e7eb; color:#222; }
    .badge-red { background:#fee2e2; color:#b91c1c; }
    .msg-actions { position:absolute; top:6px; right:8px; display:none; }
    .msg-hover .msg-actions { display:inline-block; }
    .msg-hover { background: #e0f2fe !important;}
    .msg-selected { background: #fef9c3 !important; }
  </style>
</head>
<body class="bg-white text-black transition-colors duration-300">
<div id="mainContainer">
  <aside id="sidebar">
    <div class="sidebar-header flex items-center justify-between p-4 bg-emerald-700 text-white">
      <span class="font-bold text-lg">Chat and Connect</span>
      <span>Welcome, <span id="welcomeUserSidebar"></span></span>
      <button id="dashboardBtn" class="dashboard-btn ml-2">Dashboard</button>
      <button id="toggleTheme" class="theme-btn ml-2">ðŸŒ“</button>
    </div>
    <div class="p-4 border-b flex flex-col gap-2">
      <div class="flex justify-between items-center">
        <h2 class="text-xl font-bold">Chats</h2>
        <button id="createGroupBtn" class="text-sm text-blue-600 hover:underline">+ Group</button>
      </div>
      <input id="sidebarSearch" type="text" placeholder="Search Recents, Users, Groups..." class="sidebar-search border px-2 py-1 rounded text-sm w-full bg-white dark:bg-gray-800 dark:text-white" autocomplete="off" />
    </div>
    <div class="px-4 mt-3">
      <h2 class="text-lg font-semibold text-blue-700 mb-2">Recents</h2>
      <ul id="recentsList" class="divide-y"></ul>
    </div>
    <div class="px-4 mt-3">
      <h2 class="text-lg font-semibold text-green-700">Groups</h2>
      <ul id="groupList" class="divide-y"></ul>
    </div>
    <div class="px-4 mt-3">
      <h2 class="text-lg font-semibold">Users</h2>
      <ul id="userList" class="divide-y"></ul>
    </div>
  </aside>
  <main id="chatArea" class="hide flex flex-col h-full">
    <div id="chatHeader">
      <div class="flex items-center gap-2">
        <button id="backBtn" class="text-blue-600 pr-2 md:hidden">&larr;</button>
        <span id="chatTitle"></span>
        <span id="onlineLastSeenIndicator"></span>
        <span id="typingIndicator"></span>
        <input id="chatSearchBar" placeholder="Search messages..." />
      </div>
      <div class="flex items-center gap-2">
        <button id="blockUser" class="text-sm text-red-500 ml-2">ðŸš«</button>
      </div>
    </div>
    <div id="tagReplyBar"></div>
    <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-2"></div>
    <form id="messageForm" class="flex items-center p-2 border-t gap-2">
      <input id="messageInput" type="text" placeholder="Type a message" class="flex-1 border px-3 py-2 rounded" />
      <input type="file" id="fileInput" class="hidden" />
      <button type="button" id="attachBtn" class="text-blue-600">ðŸ“Ž</button>
      <button type="submit" class="bg-blue-600 text-white px-4 py-2 rounded">Send</button>
    </form>
  </main>
</div>
<!-- Group Info Modal -->
<div id="groupInfoModal">
  <div id="groupInfoContent"></div>
</div>
<!-- Group Create Modal -->
<div id="groupModal" class="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center hidden z-40">
  <div class="bg-white p-4 rounded-lg w-96 space-y-4">
    <h3 class="text-lg font-bold">Create Group</h3>
    <input type="text" id="groupName" class="w-full border px-3 py-2 rounded" placeholder="Group Name" />
    <div class="flex gap-2 items-center">
      <label class="font-semibold">Type:</label>
      <button id="publicBtn" class="px-2 py-1 bg-emerald-100 rounded border">Public</button>
      <button id="privateBtn" class="px-2 py-1 bg-red-100 rounded border">Private</button>
    </div>
    <div id="privateFields" style="display:none;">
      <label>Password: <input type="text" id="groupPassword" class="border rounded px-2 py-1" placeholder="Set password" /></label>
    </div>
    <div id="groupUsers" class="max-h-40 overflow-y-auto space-y-2"></div>
    <div class="flex justify-end gap-2">
      <button id="createGroup" class="bg-blue-600 text-white px-4 py-2 rounded">Create</button>
      <button id="closeModal" class="text-sm text-gray-500 hover:underline">Cancel</button>
    </div>
  </div>
</div>
<div id="contextMenu" class="hidden"></div>
<script>
  // Full JavaScript for Chat and Connect App
// All features: recents from DB, sidebar, groups, users, chats, typing indicator, sticky date bars,
// reply, edit, delete, react, context menu, read ticks, mobile layout, group info modal, block/unblock,
// file attachments, theme toggle, and more.

// Firebase config and initialization
const firebaseConfig = {
  apiKey: "AIzaSyBfkUJS81minjxj0DFz4pzNnGzCtb5ZJss",
  authDomain: "locater-42fb4.firebaseapp.com",
  databaseURL: "https://locater-42fb4-default-rtdb.firebaseio.com",
  projectId: "locater-42fb4",
  storageBucket: "locater-42fb4.appspot.com",
  messagingSenderId: "250348367998",
  appId: "1:250348367998:web:d734b2b4c735b5684ae82f"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();
const storage = firebase.storage();

const currentUser = sessionStorage.getItem('username') || localStorage.getItem('username');
if (!currentUser) { alert('Session expired'); location.href = 'index.html'; }
document.getElementById('welcomeUserSidebar').textContent = currentUser;

const userList = document.getElementById("userList");
const groupList = document.getElementById("groupList");
const recentsList = document.getElementById("recentsList");
const messagesEl = document.getElementById("messages");
const chatTitle = document.getElementById("chatTitle");
const chatSearchBar = document.getElementById("chatSearchBar");
const messageForm = document.getElementById("messageForm");
const messageInput = document.getElementById("messageInput");
const attachBtn = document.getElementById("attachBtn");
const fileInput = document.getElementById("fileInput");
const backBtn = document.getElementById("backBtn");
const chatListEl = document.getElementById("sidebar");
const chatWindowEl = document.getElementById("chatArea");
const createGroupBtn = document.getElementById("createGroupBtn");
const groupModal = document.getElementById("groupModal");
const publicBtn = document.getElementById("publicBtn");
const privateBtn = document.getElementById("privateBtn");
const privateFields = document.getElementById("privateFields");
const groupPasswordEl = document.getElementById("groupPassword");
const closeModal = document.getElementById("closeModal");
const groupNameInput = document.getElementById("groupName");
const groupUsers = document.getElementById("groupUsers");
const createGroup = document.getElementById("createGroup");
const blockUserBtn = document.getElementById("blockUser");
const toggleThemeBtn = document.getElementById("toggleTheme");
const dashboardBtn = document.getElementById("dashboardBtn");
const sidebarSearch = document.getElementById("sidebarSearch");
const contextMenu = document.getElementById("contextMenu");
const groupInfoModal = document.getElementById("groupInfoModal");
const groupInfoContent = document.getElementById("groupInfoContent");
const tagReplyBar = document.getElementById("tagReplyBar");

const MESSAGE_DELETION_WINDOW = 60000; // 1 minute for delete/edit
let selectedChat = null, typingTimer;
let allUsers = {}, allGroups = {};
let messagesListener = null;
let allMessages = [];
let groupType = "public";
let replyTag = null;
let typingOtherUser = false;
let onlineLastSeenPoller = null;
let contextMsgId = null, contextMsg = null, contextMenuOpen = false;

// --- Theme ---
function setTheme(theme) {
  if (theme === "dark") {
    document.documentElement.classList.add("dark");
    document.body.classList.add("dark");
    toggleThemeBtn.innerText = "ðŸŒž";
  } else {
    document.documentElement.classList.remove("dark");
    document.body.classList.remove("dark");
    toggleThemeBtn.innerText = "ðŸŒ“";
  }
  localStorage.setItem("theme", theme);
  document.querySelectorAll("#sidebar, #chatArea, .sidebar-header").forEach(e => {
    e.classList.toggle("dark", theme === "dark");
  });
  Array.from(messagesEl.children).forEach(el => {
    el.classList.remove("msg-light", "msg-dark");
    el.classList.add(theme === "dark" ? "msg-dark" : "msg-light");
  });
}
toggleThemeBtn.onclick = () => setTheme(document.documentElement.classList.contains("dark") ? "light" : "dark");
setTheme(localStorage.getItem("theme") || "light");
dashboardBtn.onclick = () => window.location.href = "app.html";

function formatDate(ts) {
  if (!ts) return '';
  const d = new Date(ts);
  if (isNaN(d.getTime())) return '';
  const msgDay = d.toDateString(), nowDay = (new Date()).toDateString();
  if (msgDay === nowDay) return "Today";
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  if (msgDay === yesterday.toDateString()) return "Yesterday";
  return d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" });
}
function formatTime(ts) {
  const d = new Date(ts);
  return isNaN(d.getTime()) ? '' : d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" });
}

// --- Sidebar lists and recents from DB ---
function refreshUserList() {
  db.ref("users").once("value", snapshot => {
    userList.innerHTML = "";
    allUsers = snapshot.val() || {};
    Object.keys(allUsers).forEach(username => {
      if (username === currentUser) return;
      const li = document.createElement("li");
      li.className = "p-3 hover:bg-gray-100 cursor-pointer flex justify-between items-center";
      li.innerHTML = `<span>${allUsers[username].name || username}</span>`;
      li.onclick = () => openChat(username, false);
      userList.appendChild(li);
    });
    filterSidebarLists();
  });
}
db.ref("users").on("value", refreshUserList);

function refreshGroupList() {
  groupList.innerHTML = "";
  db.ref("groups").once("value", snapshot => {
    allGroups = snapshot.val() || {};
    Object.values(allGroups).forEach(group => {
      const li = document.createElement("li");
      li.className = "p-3 hover:bg-green-100 cursor-pointer text-green-700 font-semibold flex justify-between items-center";
      li.innerHTML = `<span># ${group.name}</span>`;
      li.onclick = () => openChat(group.id, true, group.name);
      groupList.appendChild(li);
    });
    filterSidebarLists();
  });
}
db.ref("groups").on("value", refreshGroupList);

// --- Recents from DB ---
function setupRecentsListener() {
  db.ref(`recents/${currentUser}`).on("value", snap => {
    let recentsArr = [];
    // If recents is an object, use Object.values; if it's a list, use snap.forEach
    const val = snap.val();
    if (val) {
      // This handles both object and array cases in Firebase
      recentsArr = Object.values(val).filter(Boolean);
    } else {
      // Defensive: if for some reason it's a list, fallback to forEach
      snap.forEach(child => {
        const item = child.val();
        if (item) recentsArr.push(item);
      });
    }
    // Sort by timestamp descending
    recentsArr.sort((a, b) => b.timestamp - a.timestamp);
    renderRecents(recentsArr);
  });
}
setupRecentsListener();

function renderRecents(arr) {
  recentsList.innerHTML = "";
  arr.forEach(item => {
    if (!item || !item.id) return; // skip empty items
    const li = document.createElement("li");
    li.className = "p-3 hover:bg-gray-100 cursor-pointer flex justify-between items-center";
    const badgeClass = item.type === "group" ? "badge-green" : "badge-blue";
    li.innerHTML = `<span>${item.type === "group" ? "# " : ""}${item.name}</span>
      <span class="badge ${badgeClass}">${item.unread || 0}</span>`;
    li.onclick = () => openChat(item.id, item.type === "group", item.name);
    recentsList.appendChild(li);
  });
}
function filterSidebarLists() {
  const query = (sidebarSearch.value || "").toLowerCase();
  function filterList(list, items, getFields) {
    Array.from(list.children).forEach((li, idx) => {
      if (!items[idx]) return li.style.display = "none";
      const { name, email, phone } = getFields(items[idx]);
      li.style.display = (
        name.toLowerCase().includes(query) ||
        email.toLowerCase().includes(query) ||
        phone.toLowerCase().includes(query)
      ) ? "" : "none";
    });
  }
  // For recents, user, group lists
  // recentsList uses recents from DB, not allUsers/allGroups
  filterList(userList, Object.keys(allUsers).filter(u => u !== currentUser), u => ({
    name: allUsers[u]?.name || u,
    email: allUsers[u]?.email || "",
    phone: allUsers[u]?.phone || ""
  }));
  filterList(groupList, Object.values(allGroups), g => ({
    name: g.name || g.id, email: "", phone: ""
  }));
}
sidebarSearch.oninput = filterSidebarLists;

function showSidebar() {
  chatListEl.classList.remove("hide");
  chatWindowEl.classList.add("hide");
}
backBtn.onclick = showSidebar;

// --- Chat logic ---
function getChatPath() {
  if (!selectedChat) return "";
  if (selectedChat.isGroup) return `groupMessages/${selectedChat.id}`;
  const ids = [currentUser, selectedChat.id].sort();
  return `messages/${ids[0]}_${ids[1]}`;
}

function openChat(id, isGroup = false, groupName = "") {
  selectedChat = { id, isGroup, groupName };
  allMessages = [];
  messagesEl.innerHTML = "";
  if (messagesListener) messagesListener.off();
  clearInterval(onlineLastSeenPoller);
  markMessagesAsRead(id, isGroup);

  // Typing indicator + online / last seen
  function updateOnlineLastSeenTyping() {
    // --- Online / last seen ---
    db.ref(`users/${id}/online`).once("value", snap => {
      if (snap.val()) {
        document.getElementById("onlineLastSeenIndicator").textContent = "Online";
      } else {
        db.ref(`users/${id}/lastSeen`).once("value", snap2 => {
          const v = snap2.val();
          if (!v) {
            document.getElementById("onlineLastSeenIndicator").textContent = "";
            return;
          }
          const d = new Date(v);
          document.getElementById("onlineLastSeenIndicator").textContent =
            "Last seen " +
            d.toLocaleDateString(undefined, { year: "numeric", month: "short", day: "numeric" }) +
            " " + d.toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit", second: "2-digit" });
        });
      }
    });

    // --- Typing indicator ---
    // Listen for typing activity directed at *this* user
    db.ref(`typing/${currentUser}`).on("value", snap => {
      const typingUserId = snap.val();
      const typingOtherUser = (typingUserId === id); // Only show if other user is typing to current user
      document.getElementById("typingIndicator").textContent = typingOtherUser ? "Typing..." : "";
      renderMessagesFiltered(chatSearchBar.value); // Show typing dots as last message
    });
  }

  if (!isGroup) {
    updateOnlineLastSeenTyping();
    onlineLastSeenPoller = setInterval(updateOnlineLastSeenTyping, 1000);
  } else {
    document.getElementById("onlineLastSeenIndicator").textContent = "";
    document.getElementById("typingIndicator").textContent = "";
    clearInterval(onlineLastSeenPoller);
  }

  // --- Group or private chat title setup ---
  if (isGroup) {
    const group = allGroups[id];
    if (!group) return alert("Group not found.");
    if (!group.members || !group.members[currentUser]) {
      const joined = promptGroupJoin(group);
      if (!joined) { showSidebar(); return; }
    }
    chatTitle.textContent = `# ${group.name}`;
    chatTitle.onclick = () => showGroupInfoModal(group);
  } else {
    chatTitle.textContent = allUsers[id]?.name || id;
    chatTitle.onclick = null;
  }

  showChatArea();
  updateBlockButton();

  // --- Load existing messages ---
  const path = getChatPath();
  db.ref(path).once("value", snap => {
    if (!snap.exists()) {
      messagesEl.innerHTML = "<div class='text-gray-500 text-center'>No messages yet.</div>";
      allMessages = [];
      return;
    }
    allMessages = [];
    snap.forEach(child => {
      const msg = child.val();
      msg._id = child.key;
      allMessages.push(msg);
    });
    allMessages.sort((a,b) => a.timestamp - b.timestamp);
    renderMessagesFiltered(chatSearchBar.value);
  });

  // --- Real-time message listeners ---
  messagesListener = db.ref(path);
  messagesListener.off();

  messagesListener.on("child_added", snap => {
    const msg = snap.val();
    msg._id = snap.key;
    if (!allMessages.find(m => m._id === msg._id)) {
      allMessages.push(msg);
      allMessages.sort((a, b) => a.timestamp - b.timestamp);
      renderMessagesFiltered(chatSearchBar.value);
    }
  });

  messagesListener.on("child_changed", snap => {
    const msg = snap.val();
    msg._id = snap.key;
    const idx = allMessages.findIndex(m => m._id === msg._id);
    if (idx !== -1) {
      allMessages[idx] = msg;
      renderMessagesFiltered(chatSearchBar.value);
    }
  });

  messagesListener.on("child_removed", snap => {
    const _id = snap.key;
    allMessages = allMessages.filter(m => m._id !== _id);
    renderMessagesFiltered(chatSearchBar.value);
  });
}


chatSearchBar.oninput = () => renderMessagesFiltered(chatSearchBar.value);

// --- Reply tag logic ---
function setReplyTag(msg, id) {
  replyTag = { id, text: msg.text };
  let tagBar = document.getElementById("tagReplyBar");
  if (tagBar) {
    tagBar.innerHTML = `<div class="input-tag-bar">
      <span>Replying to: ${msg.text.slice(0,60)}${msg.text.length>60?'...':''}</span>
      <span class="remove-tag" onclick="removeReplyTag()">Ã—</span>
    </div>`;
    window.removeReplyTag = function() {
      replyTag = null;
      tagBar.innerHTML = '';
    };
  }
}

// --- Messages rendering with sticky date bars and read ticks ---
function renderMessagesFiltered(query) {
  messagesEl.innerHTML = "";
  let lastDate = "";
  let dateSet = new Set();
  let filtered = allMessages.filter(msg =>
    !query || (msg.text && msg.text.toLowerCase().includes(query.toLowerCase())) ||
    (msg.fileName && msg.fileName.toLowerCase().includes(query.toLowerCase()))
  );
  filtered.forEach((msg) => {
    const dateStr = formatDate(msg.timestamp);
    if (dateStr && !dateSet.has(dateStr)) {
      let lastDateDiv = document.createElement("div");
      lastDateDiv.className = "date-sticky";
      lastDateDiv.textContent = dateStr;
      messagesEl.appendChild(lastDateDiv);
      dateSet.add(dateStr);
    }
    renderMessage(msg, msg._id);
  });
  // Typing indicator
  if (typingOtherUser && selectedChat && !selectedChat.isGroup) {
    const typingDiv = document.createElement("div");
    typingDiv.className = `max-w-xs px-4 py-2 rounded shadow text-sm break-words msg-light ml-auto flex items-center`;
    typingDiv.innerHTML = `<span class="typing-dots"><span></span><span></span><span></span></span>`;
    messagesEl.appendChild(typingDiv);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
}

function renderMessage(msg, id) {
  const isSender = msg.sender === currentUser;
  const div = document.createElement("div");
  div.dataset.id = id;
  div.className = `relative max-w-xs px-4 py-2 rounded shadow text-sm break-words msg-light ${isSender ? "ml-auto" : ""}`;
  div.innerHTML += msg.text || (msg.fileUrl ? `<a href="${msg.fileUrl}" target="_blank" class="underline text-blue-700">${msg.fileName}</a>` : "");

  // Reply tag
  if (msg.replyTo) {
    const replyDiv = document.createElement("div");
    replyDiv.className = "reply-tag";
    replyDiv.textContent = msg.replyText || "Replied message";
    replyDiv.onclick = () => {
      const el = document.querySelector(`[data-id="${msg.replyTo}"]`);
      if (el) {
        el.scrollIntoView({ behavior: "smooth", block: "center" });
        el.classList.add("ring", "ring-blue-500");
        setTimeout(()=>el.classList.remove("ring","ring-blue-500"), 1200);
      }
    };
    div.appendChild(replyDiv);
  }

  // Read ticks
  if (isSender) {
    const ticks = document.createElement("span");
    ticks.className = "absolute bottom-1 right-2 text-xs";
    if (msg.status === "read") {
      ticks.textContent = "âœ“âœ“";
      ticks.classList.add("text-green-700");
    } else if (msg.status === "delivered") {
      ticks.textContent = "âœ“âœ“";
    } else {
      ticks.textContent = "âœ“";
    }
    div.appendChild(ticks);
  }

  // Reactions bar
  if (msg.reactions) {
    const reactionBar = document.createElement("div");
    reactionBar.className = "flex gap-1 mt-1";
    for (const [user, emoji] of Object.entries(msg.reactions)) {
      const span = document.createElement("span");
      span.textContent = emoji;
      span.className = "inline-block px-2 py-1 rounded bg-gray-200 dark:bg-gray-700 text-lg";
      reactionBar.appendChild(span);
    }
    div.appendChild(reactionBar);
  }
  // Time
  const timeDiv = document.createElement("div");
  timeDiv.className = "text-xs text-gray-500 mt-1";
  timeDiv.textContent = formatTime(msg.timestamp);
  div.appendChild(timeDiv);

  // Context menu (right click/long press)
  div.oncontextmenu = e => {
    e.preventDefault();
    contextMsgId = id;
    contextMsg = msg;
    showContextMenu(getMsgActions(msg), e.clientX, e.clientY);
  };
  let startX = null;
  div.addEventListener("touchstart", e => { startX = e.touches[0].clientX; });
  div.addEventListener("touchend", e => {
    if (!startX) return;
    const endX = e.changedTouches[0].clientX;
    if (startX !== null && endX - startX > 60) {
      setReplyTag(msg, id);
    }
    startX = null;
  });
  let longPressTimer;
  div.addEventListener("touchstart", e => {
    longPressTimer = setTimeout(() => {
      contextMsgId = id;
      contextMsg = msg;
      showContextMenu(getMsgActions(msg), e.touches[0].clientX, e.touches[0].clientY);
    }, 400);
  });
  div.addEventListener("touchend", () => clearTimeout(longPressTimer));
  div.addEventListener("touchmove", () => clearTimeout(longPressTimer));

  if (msg.sender !== currentUser && selectedChat && !selectedChat.isGroup) {
    db.ref(`${getChatPath()}/${id}/status`).set("read");
  }
  messagesEl.appendChild(div);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

// --- Message context menu actions ---
function getMsgActions(msg) {
  const isSender = msg.sender === currentUser;
  const timeElapsed = Date.now() - msg.timestamp;
  const actions = [{ label: "Reply", action: "reply" }];
  if (isSender) {
    actions.push({ label: "Edit", action: "edit" });
    actions.push({ label: "Delete for Me", action: "deleteMe" });
    if (timeElapsed <= MESSAGE_DELETION_WINDOW) {
      actions.push({ label: "Delete for Everyone", action: "deleteEveryone" });
    }
  } else {
    actions.push({ label: "Delete for Me", action: "deleteMe" });
  }
  actions.push({ label: "React", action: "react" });
  return actions;
}
function showContextMenu(actions, x, y) {
  hideContextMenu();
  let menuHtml = "";
  actions.forEach(({ label, action }) => {
    menuHtml += `<div class="p-2 hover:bg-gray-200 cursor-pointer" data-action="${action}">${label}</div>`;
  });
  contextMenu.innerHTML = menuHtml;
  contextMenu.classList.remove("hidden");
  contextMenuOpen = true;
  const menuWidth = 180, menuHeight = 40 * actions.length, padding = 8;
  let left = x, top = y;
  if (left + menuWidth > window.innerWidth) left = window.innerWidth - menuWidth - padding;
  if (top + menuHeight > window.innerHeight) top = window.innerHeight - menuHeight - padding;
  if (left < 0) left = padding;
  if (top < 0) top = padding;
  contextMenu.style.left = left + "px";
  contextMenu.style.top = top + "px";
  contextMenu.style.transform = "";
}
function hideContextMenu() {
  contextMenu.classList.add("hidden");
  contextMenuOpen = false;
}
contextMenu.onclick = e => {
  const action = e.target.dataset.action;
  if (!action || !contextMsgId || !contextMsg) return;
  if (action === "reply") setReplyTag(contextMsg, contextMsgId);
  if (action === "edit") editMessage(contextMsgId, contextMsg.text);
  if (action === "deleteMe") deleteForMe(contextMsgId);
  if (action === "deleteEveryone") deleteForEveryone(contextMsgId);
  if (action === "react") addReaction(contextMsgId);
  hideContextMenu();
};
document.body.addEventListener("click", () => { if (contextMenuOpen) hideContextMenu(); });
window.addEventListener("scroll", hideContextMenu);
window.addEventListener("resize", hideContextMenu);

function editMessage(id, oldText) {
  const newText = prompt("Edit your message:", oldText);
  if (newText && newText.trim() && newText !== oldText) {
    db.ref(`${getChatPath()}/${id}`).update({ text: newText + " (edited)" });
  }
}
function addReaction(msgId) {
  const emoji = prompt("React with an emoji:");
  if (!emoji) return;
  db.ref(`${getChatPath()}/${msgId}/reactions/${currentUser}`).set(emoji);
}
function deleteForMe(id) {
  const bubble = document.querySelector(`[data-id="${id}"]`);
  if (bubble) bubble.remove();
}
function deleteForEveryone(id) {
  db.ref(`${getChatPath()}/${id}`).update({
    text: "ðŸš« This message was deleted.",
    fileUrl: null,
    fileName: null,
    deleted: true
  });
}

// --- Typing indicator logic ---
messageInput.oninput = () => {
  sendTyping(true);
  clearTimeout(typingTimer);
  typingTimer = setTimeout(() => sendTyping(false), 2000);
};
function sendTyping(isTyping) {
  if (!selectedChat || selectedChat.isGroup) return;
  db.ref(`typing/${selectedChat.id}`).set(isTyping ? currentUser : "");
}
function showChatArea() {
  chatListEl.classList.add("hide");
  chatWindowEl.classList.remove("hide");
}

// --- Message send logic ---
messageForm.onsubmit = async e => {
  e.preventDefault();
  const text = messageInput.value.trim();
  if (!text || !selectedChat) return;
  const msg = {
    sender: currentUser,
    text: text,
    timestamp: Date.now(),
    status: "sent"
  };
  if (replyTag) {
    msg.replyTo = replyTag.id;
    msg.replyText = replyTag.text;
    replyTag = null;
    tagReplyBar.innerHTML = '';
  }
  const ref = db.ref(getChatPath()).push();
  await ref.set(msg);
  messageInput.value = "";
  sendTyping(false);
  updateRecentsOnSend(selectedChat.id, selectedChat.isGroup, text);
};

attachBtn.onclick = () => fileInput.click();
fileInput.onchange = async () => {
 // const file = fileInput.files[0];
 // if (!file || !selectedChat) return;
  //if (file.size > 10 * 1024 * 1024) { alert("File is too large (max 10MB)."); return; }
 // const ref = storage.ref().child(`attachments/${Date.now()}_${file.name}`);
  //await ref.put(file);
 // const url = await ref.getDownloadURL();
  //const msg = { sender: currentUser, fileUrl: url, fileName: file.name, timestamp: Date.now() };
  //await db.ref(getChatPath()).push(msg);
};

// --- Group creation ---
createGroupBtn.onclick = () => {
  groupModal.classList.remove("hidden");
  groupNameInput.value = "";
  groupPasswordEl.value = "";
  groupType = "public";
  privateFields.style.display = "none";
  groupUsers.innerHTML = "";
  db.ref("users").once("value", snap => {
    const usersObj = snap.val();
    if (!usersObj) return;
    Object.keys(usersObj).forEach(username => {
      if (username === currentUser) return;
      const div = document.createElement("div");
      div.className = "flex items-center gap-2 p-1";
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = username;
      div.appendChild(checkbox);
      div.appendChild(document.createTextNode(usersObj[username].name || username));
      groupUsers.appendChild(div);
    });
  });
};
publicBtn.onclick = () => {
  groupType = "public";
  privateFields.style.display = "none";
};
privateBtn.onclick = () => {
  groupType = "private";
  privateFields.style.display = "block";
};
closeModal.onclick = () => groupModal.classList.add("hidden");
createGroup.onclick = () => {
  const name = groupNameInput.value.trim();
  if (!name) return alert("Group name required!");
  const memberCheckboxes = groupUsers.querySelectorAll("input[type=checkbox]:checked");
  if (memberCheckboxes.length < 1) return alert("Select at least one member.");
  let password = groupType === "private" ? groupPasswordEl.value.trim() : "";
  if (groupType === "private" && !password) return alert("Password required for private group.");
  const members = { [currentUser]: true };
  memberCheckboxes.forEach(cb => members[cb.value] = true);
  const groupId = "group_" + Date.now();
  db.ref(`groups/${groupId}`).set({ id: groupId, name, type: groupType, password, members });
  groupModal.classList.add("hidden");
  openChat(groupId, true, name);
};

// --- Group info modal ---
function showGroupInfoModal(group) {
  let html = `<h2 class="text-xl font-bold mb-2">${group.name}</h2>`;
  html += `<div class="mb-2">Type: <strong>${group.type || "public"}</strong></div>`;
  if (group.type === "private" && group.password) {
    html += `<div class="mb-2">Password: <span id="groupPwdText">${group.password}</span>
      <button class="copy-btn" onclick="navigator.clipboard.writeText('${group.password}')">Copy</button></div>`;
  }
  html += `<div class="mb-2">Members:</div><ul>`;
  for (const member in group.members) {
    html += `<li class="pl-2">${member}</li>`;
  }
  html += `</ul>`;
  html += `<div class="mt-4 flex gap-2">
    <button id="leaveGroupBtn" class="bg-red-500 text-white px-4 py-2 rounded">Leave Group</button>
    <button id="closeInfoBtn" class="bg-gray-500 text-white px-4 py-2 rounded">Close</button>
  </div>`;
  groupInfoContent.innerHTML = html;
  groupInfoModal.style.display = "flex";
  document.getElementById("closeInfoBtn").onclick = () => groupInfoModal.style.display = "none";
  document.getElementById("leaveGroupBtn").onclick = async () => {
    await db.ref(`groups/${group.id}/members/${currentUser}`).remove();
    groupInfoModal.style.display = "none";
    showSidebar();
    alert("You have left this group.");
  };
}

// --- Online status and cleanup ---
window.addEventListener("beforeunload", () => { db.ref(`users/${currentUser}/lastSeen`).set(Date.now()); });
db.ref(`users/${currentUser}/online`).set(true);
db.ref(`users/${currentUser}/online`).onDisconnect().set(false);
db.ref(`users/${currentUser}/lastSeen`).onDisconnect().set(Date.now());

// --- Block/Unblock user logic ---
blockUserBtn.onclick = async () => {
  if (!selectedChat || selectedChat.isGroup) return;
  const otherUser = selectedChat.id;
  const ref = db.ref(`blocked/${currentUser}/${otherUser}`);
  const isBlocked = await ref.once("value").then(snap => snap.exists());
  if (isBlocked) {
    await ref.remove();
    blockUserBtn.textContent = "ðŸš« Block";
    blockUserBtn.disabled = false;
    alert("User unblocked.");
  } else {
    await ref.set(true);
    blockUserBtn.textContent = "âœ… Unblock";
    blockUserBtn.disabled = false;
    alert("User blocked.");
  }
};

async function updateBlockButton() {
  if (!selectedChat || selectedChat.isGroup) {
    blockUserBtn.textContent = "ðŸš« Block";
    blockUserBtn.disabled = true;
    return;
  }
  const otherUser = selectedChat.id;
  const userBlockedSnap = await db.ref(`blocked/${currentUser}/${otherUser}`).once("value");
  const otherBlockedSnap = await db.ref(`blocked/${otherUser}/${currentUser}`).once("value");
  if (userBlockedSnap.exists()) {
    blockUserBtn.textContent = "âœ… Unblock";
    blockUserBtn.disabled = false;
  } else if (otherBlockedSnap.exists()) {
    blockUserBtn.textContent = "ðŸš« Blocked";
    blockUserBtn.disabled = false;
  } else {
    blockUserBtn.textContent = "ðŸš« Block";
    blockUserBtn.disabled = false;
  }
}

// --- Group join logic ---
function promptGroupJoin(group) {
  if (group.type === "private" && !group.members?.[currentUser]) {
    const pwd = prompt("This is a private group. Enter password to join:");
    if (pwd !== group.password) { alert("Wrong password."); return false; }
    db.ref(`groups/${group.id}/members/${currentUser}`).set(true);
    alert("You have joined this group!");
    return true;
  }
  if (!group.members?.[currentUser]) {
    if (!confirm("Join this group?")) return false;
    db.ref(`groups/${group.id}/members/${currentUser}`).set(true);
    alert("You have joined this group!");
    return true;
  }
  return true;
}
function updateRecentsOnSend(chatId, isGroup, text) {
  const now = Date.now();
  if (isGroup) {
    // Update recents for all group members
    const group = allGroups[chatId];
    if (!group || !group.members) return;

    Object.keys(group.members).forEach(member => {
      // If sender, unread = 0, else increment unread
      const unreadRef = db.ref(`recents/${member}/${chatId}/unread`);
      if (member === currentUser) {
        unreadRef.set(0);
      } else {
        // Increment unread for all other group members
        unreadRef.transaction(curr => (curr || 0) + 1);
      }
      db.ref(`recents/${member}/${chatId}`).update({
        id: chatId,
        name: group.name || chatId,
        type: "group",
        lastMessage: text,
        timestamp: now
      });
    });
  } else {
    // 1:1 chat: update for both users
    const users = [currentUser, chatId];
    users.forEach(user => {
      const otherUser = users.find(u => u !== user);
      const unreadRef = db.ref(`recents/${user}/${otherUser}/unread`);
      if (user === currentUser) {
        unreadRef.set(0);
      } else {
        unreadRef.transaction(curr => (curr || 0) + 1);
      }
      db.ref(`recents/${user}/${otherUser}`).update({
        id: otherUser,
        name: allUsers[otherUser]?.name || otherUser,
        type: "user",
        lastMessage: text,
        timestamp: now
      });
    });
  }
}
function markMessagesAsRead(chatId, isGroup) {
  if (isGroup) {
    db.ref(`recents/${currentUser}/${chatId}/unread`).set(0);
  } else {
    db.ref(`recents/${currentUser}/${chatId}/unread`).set(0);
  }
}
</script>
</body>
</html>
