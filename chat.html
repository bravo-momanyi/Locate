<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WhatsApp Clone</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>
  <style>
    @media (max-width: 768px) {
      #chatList {
        display: none;
      }
      #chatWindow {
        display: flex !important;
      }
    }

    @media (min-width: 768px) {
      #chatWindow {
        display: flex;
      }
    }

    video#localVideo {
      width: 100px;
      height: 100px;
      object-fit: cover;
    }

    video#remoteVideo {
      width: 100%;
      height: 300px;
      object-fit: cover;
    }
  </style>
</head>
<body class="flex flex-col md:flex-row h-screen bg-white dark:bg-gray-900 text-black dark:text-white">

  <!-- Header -->
  <header class="w-full md:hidden bg-blue-600 text-white p-4">
    <h1 class="text-xl font-bold">Welcome, <span id="welcomeUserMobile"></span></h1>
  </header>

  <!-- Chat List Sidebar -->
  <aside id="chatList" class="w-full md:w-1/3 lg:w-1/4 border-r border-gray-300 overflow-y-auto hidden md:block">
    <div class="flex justify-between items-center p-4 border-b">
      <h2 class="text-xl font-bold">Chats</h2>
      <button id="createGroupBtn" class="text-sm text-blue-600 hover:underline">+ Group</button>
    </div>
    <ul id="userList" class="divide-y"></ul>
  </aside>

  <!-- Chat Window -->
  <main id="chatWindow" class="flex-1 flex flex-col hidden">
    <!-- Chat Header -->
    <div id="chatHeader" class="flex items-center justify-between px-4 py-2 border-b bg-gray-100">
      <div class="flex items-center gap-2">
        <button id="backBtn" class="md:hidden text-blue-600 pr-2">&larr;</button>
        <div>
          <h2 id="chatName" class="text-lg font-semibold"></h2>
          <p id="chatStatus" class="text-sm text-gray-500"></p>
        </div>
      </div>
      <div class="flex items-center gap-2">
        <input id="searchInput" type="text" placeholder="Search..." class="border px-2 py-1 rounded text-sm hidden md:inline-block" />
        <button id="toggleTheme" class="text-sm text-gray-600 hover:text-black">🌓</button>
        <button id="blockUser" class="text-sm text-red-500">🚫 Block</button>
      </div>
    </div>

    <!-- Messages Area -->
    <div id="messages" class="flex-1 overflow-y-auto p-4 space-y-2 bg-white dark:bg-gray-800"></div>

    <!-- Typing Indicator -->
    <div id="typing" class="text-sm text-gray-400 px-4 py-1 hidden">Typing...</div>

    <!-- Message Input -->
    <form id="messageForm" class="flex items-center p-2 border-t gap-2 bg-gray-50">
      <input id="messageInput" type="text" placeholder="Type a message" class="flex-1 border px-3 py-2 rounded" />
      <input type="file" id="fileInput" class="hidden" />
      <button type="button" id="attachBtn" class="text-blue-600">📎</button>
      <button type="submit" class="bg-blue-600 text-white px-4 py-2 rounded">Send</button>
    </form>

    <!-- Call Controls (moved to top right to avoid overlap) -->
    <div id="callControls" class="fixed top-4 right-4 flex flex-col space-y-2 z-50">
      <button id="audioCallBtn" class="bg-green-500 text-white px-4 py-2 rounded shadow">📞 Audio</button>
      <button id="videoCallBtn" class="bg-blue-600 text-white px-4 py-2 rounded shadow">🎥 Video</button>
    </div>

    <!-- Call Modal -->
    <div id="callModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50">
      <div class="bg-white p-6 rounded-lg text-center space-y-4 w-full max-w-md mx-auto">
        <h3 id="callTitle" class="text-xl font-bold">Calling...</h3>
        <video id="remoteVideo" autoplay playsinline class="bg-black rounded"></video>
        <video id="localVideo" autoplay playsinline muted class="rounded-full absolute bottom-4 right-4 z-10 border-2 border-white"></video>
        <button id="endCallBtn" class="bg-red-600 text-white px-4 py-2 rounded">End Call</button>
      </div>
    </div>
  </main>
  <!-- Group Modal -->
  <div id="groupModal" class="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center hidden z-40">
    <div class="bg-white p-4 rounded-lg w-96 space-y-4">
      <h3 class="text-lg font-bold">Create Group</h3>
      <input type="text" id="groupName" class="w-full border px-3 py-2 rounded" placeholder="Group Name" />
      <div id="groupUsers" class="max-h-40 overflow-y-auto space-y-2"></div>
      <div class="flex justify-end gap-2">
        <button id="createGroup" class="bg-blue-600 text-white px-4 py-2 rounded">Create</button>
        <button id="closeModal" class="text-sm text-gray-500 hover:underline">Cancel</button>
      </div>
    </div>
  </div>
<script>
   // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBfkUJS81minjxj0DFz4pzNnGzCtb5ZJss",
      authDomain: "locater-42fb4.firebaseapp.com",
      databaseURL: "https://locater-42fb4-default-rtdb.firebaseio.com",
      projectId: "locater-42fb4",
      storageBucket: "locater-42fb4.appspot.com",
      messagingSenderId: "250348367998",
      appId: "1:250348367998:web:d734b2b4c735b5684ae82f"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const storage = firebase.storage();

    // Get current user from session
    const currentUser = sessionStorage.getItem('username') || localStorage.getItem('username');
    if (!currentUser) {
      alert('Session expired');
      location.href = 'index.html';
    }
    document.getElementById('welcomeUserMobile').textContent = currentUser;


    // Elements
    const userList = document.getElementById("userList");
    const messagesEl = document.getElementById("messages");
    const chatHeader = document.getElementById("chatHeader");
    const chatName = document.getElementById("chatName");
    const chatStatus = document.getElementById("chatStatus");
    const messageForm = document.getElementById("messageForm");
    const messageInput = document.getElementById("messageInput");
    const attachBtn = document.getElementById("attachBtn");
    const fileInput = document.getElementById("fileInput");
    const typingEl = document.getElementById("typing");
    const searchInput = document.getElementById("searchInput");
    const backBtn = document.getElementById("backBtn");
    const chatListEl = document.getElementById("chatList");
    const chatWindowEl = document.getElementById("chatWindow");

    let selectedChat = null;
    let typingTimer;
    let quoteText = "";

    // Notification permission
    if ("Notification" in window && Notification.permission !== "granted") {
      Notification.requestPermission();
    }

    // Load users from Firebase
    db.ref("users").on("value", snapshot => {
      userList.innerHTML = "";
      snapshot.forEach(child => {
        const username = child.key;
        if (username === currentUser) return;
        const li = document.createElement("li");
        li.className = "p-3 hover:bg-gray-100 cursor-pointer";
        li.textContent = username;
        li.onclick = () => openChat(username, false);
        userList.appendChild(li);
      });
    });

    // Load groups
    db.ref("groups").on("child_added", snap => {
      const group = snap.val();
      if (!group.members || !group.members[currentUser]) return;
      const li = document.createElement("li");
      li.className = "p-3 hover:bg-gray-100 cursor-pointer text-green-600";
      li.textContent = `# ${group.name}`;
      li.onclick = () => openChat(group.id, true);
      userList.appendChild(li);
    });

    // Search messages
    searchInput.oninput = () => {
      const query = searchInput.value.toLowerCase();
      const messages = messagesEl.querySelectorAll("div[data-id]");
      messages.forEach(m => {
        const match = m.textContent.toLowerCase().includes(query);
        m.style.display = match ? "" : "none";
      });
    };

    // Handle back button (mobile)
    backBtn.onclick = () => {
      chatListEl.classList.remove("hidden");
      chatWindowEl.classList.add("hidden");
    };

    // Chat open
    function openChat(id, isGroup = false) {
      selectedChat = { id, isGroup };
      messagesEl.innerHTML = "";
      chatName.textContent = isGroup ? `# ${id}` : id;
      chatStatus.textContent = isGroup ? "Group" : "Loading...";

      if (!isGroup) {
        db.ref(`users/${id}/lastSeen`).on("value", snap => {
          const val = snap.val();
          if (!val) return;
          chatStatus.textContent = `last seen ${new Date(val).toLocaleTimeString()}`;
        });
      }

      chatListEl.classList.add("hidden");
      chatWindowEl.classList.remove("hidden");

      db.ref(getChatPath()).off();
      db.ref(getChatPath()).on("child_added", snap => {
        const msg = snap.val();
        renderMessage(msg, snap.key);
      });
    }

    function getChatPath() {
      if (!selectedChat) return "";
      if (selectedChat.isGroup) return `groupMessages/${selectedChat.id}`;
      const ids = [currentUser, selectedChat.id].sort();
      return `messages/${ids[0]}_${ids[1]}`;
    }
    // Render each message
   function renderMessage(msg, id) {
  const div = document.createElement("div");
  div.dataset.id = id;
  div.className = `relative max-w-xs px-4 py-2 rounded shadow text-sm break-words ${
    msg.sender === currentUser ? "bg-blue-100 ml-auto" : "bg-gray-100"
  }`;

  div.innerHTML = msg.text || (msg.fileUrl ? `<a href="${msg.fileUrl}" target="_blank">📎 ${msg.fileName}</a>` : "");

  // Ticks & status
  if (msg.sender === currentUser) {
    const ticks = document.createElement("span");
    ticks.className = "absolute bottom-1 right-2 text-xs";

    if (msg.status === "read") {
      ticks.textContent = "✓✓";
      ticks.classList.add("text-blue-500");
    } else if (msg.status === "delivered") {
      ticks.textContent = "✓✓";
    } else {
      ticks.textContent = "✓";
    }
    div.appendChild(ticks);
  } else {
    // ✅ Fix: check if selectedChat exists before accessing it
    if (selectedChat && !selectedChat.isGroup) {
      db.ref(`${getChatPath()}/${id}/status`).set("read");
    }
  }
      // Message ticks
      if (msg.sender === currentUser) {
        const ticks = document.createElement("span");
        ticks.className = "absolute bottom-1 right-2 text-xs";
        if (msg.status === "read") {
          ticks.textContent = "✓✓";
          ticks.classList.add("text-blue-500");
        } else if (msg.status === "delivered") {
          ticks.textContent = "✓✓";
        } else {
          ticks.textContent = "✓";
        }
        div.appendChild(ticks);

        // Edit icon
        if (!msg.deleted) {
          const edit = document.createElement("span");
          edit.textContent = " ✏️";
          edit.className = "cursor-pointer ml-2 text-blue-500";
          edit.onclick = () => editMessage(id, msg.text);
          div.appendChild(edit);
        }

        // Delete icon
        const del = document.createElement("span");
        del.textContent = " ❌";
        del.className = "cursor-pointer ml-2 text-red-500";
        del.onclick = () => deleteMessage(id);
        div.appendChild(del);
      } else {
        // Mark as read if it's incoming
        if (!selectedChat.isGroup) {
          db.ref(`${getChatPath()}/${id}/status`).set("read");
        }
      }

      // Reactions
      if (msg.reactions) {
        const reactionBar = document.createElement("div");
        reactionBar.className = "text-sm mt-1";
        for (const [user, emoji] of Object.entries(msg.reactions)) {
          const span = document.createElement("span");
          span.textContent = emoji;
          span.className = "mr-1";
          reactionBar.appendChild(span);
        }
        div.appendChild(reactionBar);
      }

      // Swipe to reply (mobile)
      let startX = null;
      div.addEventListener("touchstart", e => {
        startX = e.touches[0].clientX;
      });
      div.addEventListener("touchend", e => {
        if (!startX) return;
        const endX = e.changedTouches[0].clientX;
        if (endX - startX > 80 && msg.sender !== currentUser) {
          quoteMessage(msg.text);
        }
        startX = null;
      });

      // Reply
      const reply = document.createElement("span");
      reply.textContent = " ↩️";
      reply.className = "cursor-pointer ml-2 text-green-500";
      reply.onclick = () => quoteMessage(msg.text);
      div.appendChild(reply);

      // Star
      const star = document.createElement("span");
      star.textContent = " ⭐";
      star.className = "cursor-pointer ml-2 text-yellow-500";
      star.onclick = () => toggleStar(id, msg);
      div.appendChild(star);

      // React
      const react = document.createElement("span");
      react.textContent = " 😊";
      react.className = "cursor-pointer ml-2";
      react.onclick = () => addReaction(id);
      div.appendChild(react);

      messagesEl.appendChild(div);
      messagesEl.scrollTop = messagesEl.scrollHeight;

      // Push Notification if incoming
      if (msg.sender !== currentUser && document.hidden) {
        new Notification(`New message from ${msg.sender}`, {
          body: msg.text,
          icon: "/assets/whatsapp-icon.png"
        });
      }
    }

    // Quoting messages (replies)
    function quoteMessage(text) {
      quoteText = text;
      messageInput.value = `> ${text}\n`;
      messageInput.focus();
    }

    // Send Message
    messageForm.onsubmit = async e => {
      e.preventDefault();
      const text = messageInput.value.trim();
      if (!text || !selectedChat) return;

      // Check if blocked
      const blockedRef = db.ref(`blocked/${selectedChat.id}/${currentUser}`);
      const blockedSnap = await blockedRef.once("value");
      if (blockedSnap.exists()) {
        alert("You are blocked by this user.");
        return;
      }

      const msg = {
        sender: currentUser,
        text: quoteText ? `${quoteText}\n\n${text}` : text,
        timestamp: Date.now(),
        status: "sent"
      };

      const ref = db.ref(getChatPath()).push();
      await ref.set(msg);
      quoteText = "";
      messageInput.value = "";
      sendTyping(false);

      // Immediately mark delivered if user is online
      if (!selectedChat.isGroup) {
        const statusRef = db.ref(`users/${selectedChat.id}/online`);
        statusRef.once("value", snap => {
          if (snap.val()) {
            ref.update({ status: "delivered" });
          }
        });
      }
    };

    // Typing indicator
    messageInput.oninput = () => {
      sendTyping(true);
      clearTimeout(typingTimer);
      typingTimer = setTimeout(() => sendTyping(false), 2000);
    };

    function sendTyping(isTyping) {
      if (!selectedChat || selectedChat.isGroup) return;
      db.ref(`typing/${selectedChat.id}`).set(isTyping ? currentUser : "");
    }

    // Listen for typing from others
    db.ref(`typing/${currentUser}`).on("value", snap => {
      const typer = snap.val();
      typingEl.classList.toggle("hidden", !typer);
      if (typer) typingEl.textContent = `${typer} is typing...`;
    });
    // File Attachments
    attachBtn.onclick = () => fileInput.click();

    fileInput.onchange = async () => {
      const file = fileInput.files[0];
      if (!file || !selectedChat) return;

      const ref = storage.ref().child(`attachments/${Date.now()}_${file.name}`);
      await ref.put(file);
      const url = await ref.getDownloadURL();

      const msg = {
        sender: currentUser,
        fileUrl: url,
        fileName: file.name,
        timestamp: Date.now()
      };

      await db.ref(getChatPath()).push(msg);
    };

    // Delete Message
    function deleteMessage(id) {
      const msgRef = db.ref(`${getChatPath()}/${id}`);
      msgRef.once("value", snap => {
        const msg = snap.val();
        if (!msg) return;

        const timeElapsed = Date.now() - msg.timestamp;
        const canDeleteForEveryone = msg.sender === currentUser && timeElapsed <= 60000;

        const confirmText = canDeleteForEveryone
          ? "Delete for everyone or just for you?"
          : "Delete for me only?";

        const confirmed = confirm(confirmText);

        if (confirmed && canDeleteForEveryone) {
          msgRef.update({
            text: "🚫 This message was deleted.",
            fileUrl: null,
            fileName: null,
            deleted: true
          });
        } else {
          // Local delete only
          const bubble = document.querySelector(`[data-id="${id}"]`);
          if (bubble) bubble.remove();
        }
      });
    }

    // Edit Message
    function editMessage(id, oldText) {
      const newText = prompt("Edit your message:", oldText);
      if (newText && newText.trim() && newText !== oldText) {
        db.ref(`${getChatPath()}/${id}`).update({
          text: newText + " (edited)"
        });
      }
    }

    // Starred Messages
    function toggleStar(id, msg) {
      const ref = db.ref(`stars/${currentUser}/${id}`);
      ref.once("value", snap => {
        if (snap.exists()) {
          ref.remove();
        } else {
          ref.set({ ...msg, chatId: getChatPath() });
        }
      });
    }

    // Load starred messages on load
    db.ref(`stars/${currentUser}`).once("value", snap => {
      snap.forEach(child => {
        renderMessage(child.val(), child.key);
      });
    });

    // Reactions
    function addReaction(msgId) {
      const emoji = prompt("React with emoji:");
      if (!emoji) return;
      db.ref(`${getChatPath()}/${msgId}/reactions/${currentUser}`).set(emoji);
    }

    // Blocking a user
    document.getElementById("blockUser").onclick = () => {
      if (!selectedChat || selectedChat.isGroup) return;
      const confirmBlock = confirm(`Block ${selectedChat.id}?`);
      if (confirmBlock) {
        db.ref(`blocked/${currentUser}/${selectedChat.id}`).set(true);
      }
    };

    // Last Seen & Online Tracking
    window.addEventListener("beforeunload", () => {
      db.ref(`users/${currentUser}/lastSeen`).set(Date.now());
    });
    db.ref(`users/${currentUser}/online`).set(true);
    db.ref(`users/${currentUser}/online`).onDisconnect().set(false);
    db.ref(`users/${currentUser}/lastSeen`).onDisconnect().set(Date.now());

    // Theme Toggling
    const toggleThemeBtn = document.getElementById("toggleTheme");
    toggleThemeBtn.onclick = () => {
      document.documentElement.classList.toggle("dark");
      localStorage.setItem("theme", document.documentElement.classList.contains("dark") ? "dark" : "light");
    };

    // Apply saved theme on load
    if (localStorage.getItem("theme") === "dark") {
      document.documentElement.classList.add("dark");
    }

    // Responsive mobile layout fix
    window.addEventListener("resize", () => {
      if (window.innerWidth >= 768) {
        chatListEl.classList.remove("hidden");
        chatWindowEl.classList.add("md:flex");
      }
    });

    // Fix call buttons overlapping send input
    const callControls = document.getElementById("callControls");
    callControls.classList.remove("fixed");
    callControls.classList.add("absolute", "bottom-20", "right-4");

    // Adjust for mobile
    if (window.innerWidth < 768) {
      chatListEl.classList.remove("hidden");
      chatWindowEl.classList.add("hidden");
    }

    backBtn.onclick = () => {
      chatListEl.classList.remove("hidden");
      chatWindowEl.classList.add("hidden");
    };
    // === Call Buttons ===
    const audioCallBtn = document.getElementById("audioCallBtn");
    const videoCallBtn = document.getElementById("videoCallBtn");
    const callModal = document.getElementById("callModal");
    const callTitle = document.getElementById("callTitle");
    const endCallBtn = document.getElementById("endCallBtn");
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");

    let pc = null;
    let localStream = null;
    let remoteStream = null;
    let isCaller = false;

    const servers = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };

    audioCallBtn.onclick = () => startCall(false);
    videoCallBtn.onclick = () => startCall(true);

    async function startCall(withVideo) {
      if (!selectedChat || selectedChat.isGroup) {
        alert("Calls are only supported in private chats.");
        return;
      }

      isCaller = true;
      callModal.classList.remove("hidden");
      callTitle.textContent = "Calling...";

      localStream = await navigator.mediaDevices.getUserMedia({
        video: withVideo,
        audio: true
      });

      localVideo.srcObject = localStream;

      setupPeer();
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      const callRef = db.ref(`calls/${selectedChat.id}`);
      callRef.set({
        from: currentUser,
        offer: JSON.stringify(offer),
        video: withVideo
      });

      const callLog = {
        with: selectedChat.id,
        type: withVideo ? "video" : "audio",
        time: Date.now(),
        direction: "outgoing"
      };
      db.ref(`callsHistory/${currentUser}`).push(callLog);

      callRef.on("value", async snap => {
  const data = snap.val();
  if (!data || data.from === currentUser) return;

  try {
    if (data.answer && pc && pc.signalingState !== "closed") {
      await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(data.answer)));
    }

    if (data.candidate && pc && pc.signalingState !== "closed") {
      await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(data.candidate)));
    }
  } catch (err) {
    console.error("ICE error", err);
  }
});

    }
  db.ref(`calls/${currentUser}`).on("child_removed", snap => {
  if (callHandled || minimized) {
    endCall("ended");
    alert("Call ended by the other user.");
  }
});

    function setupPeer() {
      pc = new RTCPeerConnection(servers);
      remoteStream = new MediaStream();
      remoteVideo.srcObject = remoteStream;

      pc.ontrack = event => {
  event.streams[0].getTracks().forEach(track => {
    remoteStream.addTrack(track);
  });
};


      pc.onicecandidate = event => {
        if (event.candidate) {
          const ref = db.ref(`calls/${isCaller ? selectedChat.id : currentUser}`);
          ref.update({ candidate: JSON.stringify(event.candidate) });
        }
      };
    }

    // === Incoming Calls ===
// === Incoming Calls ===
db.ref(`calls/${currentUser}`).on("value", async snap => {
  const data = snap.val();
  if (!data || data.from === currentUser || callHandled || minimized) return;

  showIncomingPopup(data.from, data.video);

  callTimeoutTimer = setTimeout(() => {
    if (!callHandled) {
      endCall("timeout");
      alert("Missed call from " + data.from);
    }
  }, 60000);
});


function showIncomingPopup(fromUser, isVideo) {
  callModal.classList.remove("hidden");
  callTitle.textContent = `${fromUser} is calling...`;

  // Add accept, reject, and cancel buttons dynamically if needed
  callModal.innerHTML = `
    <div class="bg-white p-6 rounded-lg text-center space-y-4 w-full max-w-md mx-auto">
      <h3 class="text-xl font-bold">${fromUser} is calling...</h3>
      <div class="flex justify-center gap-4">
        <button id="acceptCall" class="bg-green-500 text-white px-4 py-2 rounded">Accept</button>
        <button id="cancelCall" class="bg-yellow-500 text-white px-4 py-2 rounded">Cancel</button>
        <button id="rejectCall" class="bg-red-600 text-white px-4 py-2 rounded">Reject</button>
      </div>
    </div>
  `;

  document.getElementById("acceptCall").onclick = async () => {
    clearTimeout(callTimeoutTimer);
    await acceptIncomingCall(fromUser, isVideo);
  };

  document.getElementById("rejectCall").onclick = () => {
    clearTimeout(callTimeoutTimer);
    endCall("rejected");
  };

  document.getElementById("cancelCall").onclick = () => {
    callModal.classList.add("hidden");
    minimized = true; // Still ringing in background
  };
}
  async function acceptIncomingCall(fromUser, withVideo) {
  callModal.classList.remove("hidden");
  callTitle.textContent = "In Call...";
  localStream = await navigator.mediaDevices.getUserMedia({
    video: withVideo,
    audio: true
  });
  localVideo.srcObject = localStream;

  setupPeer();
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  const callRef = db.ref(`calls/${currentUser}`);
  const snap = await callRef.once("value");
  const data = snap.val();
  if (!data || !data.offer) return;

  await pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(data.offer)));

  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  callHandled = true;

  await callRef.update({
    answer: JSON.stringify(answer)
  });

  // Track ICE candidates
  callRef.on("value", async snap => {
    const data = snap.val();
    if (!data || data.from === currentUser) return;
    if (data.candidate && pc && pc.signalingState !== "closed") {
      try {
        await pc.addIceCandidate(new RTCIceCandidate(JSON.parse(data.candidate)));
      } catch (err) {
        console.error("Error adding ICE candidate", err);
      }
    }
  });

  // Log call history
  const callLog = {
    with: fromUser,
    type: withVideo ? "video" : "audio",
    time: Date.now(),
    direction: "incoming"
  };
  db.ref(`callsHistory/${currentUser}`).push(callLog);
}


    // === End Call ===
    function endCall(reason = "ended") {
  callModal.classList.add("hidden");
  callHandled = false;
  minimized = false;
  clearTimeout(callTimeoutTimer);

  if (pc) pc.close();
  if (localStream) localStream.getTracks().forEach(t => t.stop());

  if (selectedChat) {
    db.ref(`calls/${selectedChat.id}`).remove();
  }
  db.ref(`calls/${currentUser}`).remove();

  if (reason === "rejected" || reason === "timeout") {
    console.log("Call " + reason);
  }
}

    // === Load Call Logs to Console ===
    db.ref(`callsHistory/${currentUser}`).once("value", snap => {
      snap.forEach(child => {
        const log = child.val();
        console.log(`[${log.direction}] ${log.with} - ${log.type} at ${new Date(log.time).toLocaleTimeString()}`);
      });
    });
    // === Toggle Dark Mode ===
  
    // === Block User ===
    document.getElementById("blockUser").onclick = () => {
      if (!selectedChat || selectedChat.isGroup) return;
      const confirmBlock = confirm(`Block ${selectedChat.id}?`);
      if (!confirmBlock) return;
      db.ref(`blocked/${currentUser}/${selectedChat.id}`).set(true);
      alert(`${selectedChat.id} has been blocked.`);
    };

    // === Starred Messages ===
    function toggleStar(id, msg) {
      const ref = db.ref(`stars/${currentUser}/${id}`);
      ref.once("value", snap => {
        if (snap.exists()) {
          ref.remove();
        } else {
          ref.set({ ...msg, chatId: getChatPath() });
        }
      });
    }

    // Load Starred Messages on Startup
    db.ref(`stars/${currentUser}`).once("value", snap => {
      snap.forEach(child => {
        renderMessage(child.val(), child.key);
      });
    });

    // === React to Message ===
    function addReaction(msgId) {
      const emoji = prompt("React with an emoji:");
      if (!emoji) return;
      db.ref(`${getChatPath()}/${msgId}/reactions/${currentUser}`).set(emoji);
    }

    // === Last Seen & Online Update on Exit ===
    window.addEventListener("beforeunload", () => {
      db.ref(`users/${currentUser}/lastSeen`).set(Date.now());
    });

    // Online presence management
    db.ref(`users/${currentUser}/online`).set(true);
    db.ref(`users/${currentUser}/online`).onDisconnect().set(false);
    db.ref(`users/${currentUser}/lastSeen`).onDisconnect().set(Date.now());

</script>
</body>
</html>
   
